## js是解释型语言还是编译型语言？
高级语言->汇编语言->机器语言
### 编译型语言
代码在执行前需要预编译，转换成机器语言，运行时直接使用编译结果即可。

特点：

- 在编译过程中，会进行代码优化
- 编译后执行速度快，相比解释型对系统要求低
- 有专门的编译器
- 跨平台性不好 
   - 例如：比如c语言针对不同系统，需要编译成不同的机器语言(如windows编译成ext文件，linux编译成erp文件)，多个平台若多个版本，将非常难以维护。

### 解释型语言
代码在执行前不需要预先编译，在运行时必须先解释再执行。

特点：

- 在编译过程中，可能有优化但是较少
- 执行一次就要编译一次，速度较慢，效率比较低（JIT）
- 有专门的解释器：在源代码执行时被翻译成平台无关的中间代码，解释器会把这些代码翻译成机器语言
- 跨平台好 
   - 例如Java首先通过编译器编译成class文件，如果在windows平台上运行，将通过该平台的JVM进行解释，同理linux。所以说能跨平台，前提是平台上有匹配的JVM或者说是解释器。

### 各有利弊
对执行速度快，要求低的如操作系统，大型应用程序等，一般采用编译型语言。
对执行速度要求不高，平台兼容性高的程序，一般采用解释性语言，如Java、JS、PY

### 争端
对于JS的归属，一直都有争议：
> JavaScript ( JS ) 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言 - MDN
尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。- 你不知道的JS上


可以理解《你不知道的JS》的定论，因为JS的编译过程和传统的编译过程类似。
那么应该如何解释以下质疑：

1. 如果 JS 是解释型语言那为什么会有变量提升（hoisting）？
1. JIT（及时编译）会做代码优化(同时创建代码的编译版本)；解释型语言是无法做到这些的

解释：

1. 变量提升不是代码修改。在这个过程中没有生成中间代码。变量提升只是 JS 解释器处理事情的方式
1. JavaScript 代码需要在机器（node 或者浏览器）上安装一个工具（JS 引擎）才能执行。这是解释型语言需要的。编译型语言程序能够自由地直接运行。
1. JIT 是唯一一点我们可以对 JavaScript 是否是一个解释型语言提出疑问的理由。但是 JIT 不是完整的编译器，它在执行前进行编译。而且 JIT 只是 Mozilla 和 Google 的开发人员为了提升浏览器性能才引入的。JavaScript 或 TC39 从来没有强制要求使用 JIT。

## 拓展传统编译语言的流程

1.  分词/词法分析
   这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代 码块被称为词法单元（token）。
1.  语法分析生成AST
   这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST)
1.  生成代码
   将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关 

## JS执行语句的过程

![v81](~@imgs/v81.jpeg)

![v82](~@imgs/v82.jpeg)

上图展示了V8引擎是如何工作的：

1. 词法分析
   scanner 是一个扫描器，用于对纯文本的 JavaScript 代码进行词法分析。它会将代码分析为 tokens

2. 语法分析
   - parser 模块可以理解为是一个解析器。解析过程是一个语法分析的过程，它会将词法分析结果 tokens 转换为抽象语法树「Abstract Syntax Tree」，同时会验证语法，如果有错误就抛出语法错误。
   - 预解析方案：
      - 主流的 JavaScript 引擎都采用了**惰性解析**(Lazy Parsing)，因为源码在执行前如果全部完全解析的话，不仅会造成执行时间过长，而且会消耗更多的内存以及磁盘空间。
      -  **惰性解析就是指如果遇到并不是立即执行的函数，只会对其进行预解析(Pre-Parser)，当函数被调用时，才会对其完全解析。**
      -  预解析时，只会验证函数的语法是否有效、解析函数声明以及确定函数作用域，并不会生成 AST，这项工作由 Pre-Parser 预解析器完成
   - 预解析特点：
      - 预解析会跳过未被使用的代码
      - 不会生成 AST，会产生不带有变量引用和声明的 scopes 信息
      - 解析速度快
      - 根据规范抛出特定的错误
   - 全量解析特点：
      - 解析被使用的代码
      - 生成 AST
      - 构建具体的 scopes 信息，变量的引用，声明等
      - 抛出所有的语法错误

此时对应的，其实就是**执行上下文**的创建过程，关于执行上下文我们后续详细分析。需要区分的是，作用域与作用域链的信息是在预解析阶段就已经明确了。
同时，由于预解析的特点，JavaScript 引擎会重复执行编译和执行这两个阶段，并同时增加和删除执行上下文。所以一个上下文可能会多次被添加删除。

3. 生成字节码
   1. Ignition 是 v8 提供的一个解释器。
   1. 他的作用是负责将抽象语法树 AST 转换为字节码。并且同时收集下一个阶段「编译」所需要的信息。这个过程，我们也可以理解为预编译过程。基于性能的考虑，预编译过程与编译过程有的时候不会区分的那么明显，有的代码在预编译阶段就能直接执行。

4. 编译器

TurboFan 是 v8 引擎的编译器模块。它会利用 Ignition 收集到的信息，将字节码转换为汇编代码。这也就是代码被最终执行的阶段。

Ignition + TurboFan 的组合，就是字节码解释器 + JIT 编译器的黄金组合「边解释边执行」。Ignition 收集大量的信息，交给 TurboFan 去优化，多方面条件都满足的情况下，会被优化成机器码，这个过程称为 Optimize，当判断无法优化时就会触发去优化「De-optimize」操作，这些代码逻辑会重新回到 Ignition 中称为字节码。

在这个过程中，有一个建议能够帮助我们避免去优化操作，从而提高代码执行效率。那就是**不要总是改变对象类型。**

## 浏览器解析过程
```var a = 1```

**具体过程**
1. 分词：scanner进行词法分析，将代码转成tokens
2. 语法分析：Parser解释器将对tokens进行语法分析，并生成AST，同时验证语法错误，有错误则抛出。在此时生成了作用域。（声明a如果没有）
3. 生成字节码：Ignition解释器将AST生成字节码，同时收集编译阶段需要的信息（将赋值操作转换为字节码）
4. 编译：TurboFan编译器将字节码生成汇编代码。
5. 执行：根据作用域链查找该变量，如果作用域中有该变量则进行赋值（或者说根据作用域+执行上下文进行具体之查找，具体见执行上下文）


误区：
但是当解释器进行代码生成时，它对这段代码的处理方式会和预期的情况有所不同。
当我们看到这行代码，用伪代码与别人进行概括时，可能会表述为：为一个变量分配内存，并将其命名为变量 a，然后将值 1 保存到这个变量（内存）中。

然而，这并不完全正确。
事实上编译器会进行如下操作：
1.执行流遇到 var a，解释器(编译器)会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，解释器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。接下来解释器会为引擎生成运行所需的代码，这些代码被用来处理 a = 2 这个赋值操作。（你不知道的JS书中认为这是编译器做的事情，根据上述知识我认为不够具体，应该是解释器Parser和Ignition，同时对应作用域的明确阶段）
2.引擎运行时会首先询问作用域，在当前的作用域集合中，是否存在一个叫作 a 的变量。如果是，引擎就会使用这个变量；如果否，引擎就会继续查找该变量。（你不知道的JS书中认为这是引擎做的事情，具体是哪个模块或者线程呢？）


*在上面的第二步中，引擎执行运行时所需的代码时，会通过查找变量 a 来判断它是否已经声明过。查找的过程由作用域进行协助，但是引擎执行怎么查找，会影响最终的查找结果。补充学习LHS和RHS，简单来说一个查找变量容器(LHS)、一个查找变量值(RHS)。

## 变量查找规则
补充了解即可

### LHS RHS

> 下面出自 你不知道的JS 上

那么 LHS 和 RHS 查询是什么呢？

这里的 L 代表左侧，R 代表右侧。通俗且不严谨的解释 LHS 和 RHS 的含义就是：当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。

那么描述的更准确的一点，RHS 查询与简单的查找某个变量的值毫无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。

从这个角度说，RHS 并不是真正意义上的"赋值操作的右侧"，更准确的说是"非左侧"。所以，我们可以将 RHS 理解成 Retrieve his source value（取到它的源值），这意味着，"得到某某的值"。

那我们来看一段代码深入理解一下 LHS 与 RHS。

```
function foo(a) {
  console.log(a);
}

foo(2);
```
在 ``console.log(a)`` 中，变量 a 的引用是一个 RHS 引用，因为我们是取到 a 的值。并将这个值传递给 console.log(…) 方法
相比之下，例如： a = 2 ，调用 foo(2) 时，隐式的进行了赋值操作。这里对 a 的引用就是 LHS 引用，因为我们实际上不关心当前的值时什么，只要想把 =2 这个赋值操作找到一个目标。

LHS 和 RHS 的含义是 赋值操作的左侧或右侧 并不一定意味着就是 = 赋值操作符的左侧或右侧。
赋值操作还有其他几种形式，因此在概念上最好将其理解 赋值操作的目标是谁（LHS） 以及 谁是赋值操作的源头（RHS）。

当然上面的程序并不只有一个 LHS 和 RHS 引用：

```
function foo(a) {
   // 这里隐式的进行了对形参 a 的 LHS 引用。

   // 这里对 log() 方法进行了 RHS 引用，询问 console 对象上是否有 log() 方法。
   // 对 log(a) 方法内的 a 进行 RHS 引用，取到 a 的值。
   console.log(a);
   // 2
}
// 此处调用 foo() 方法，需要调用对 foo 的 RHS 引用。意味着"去找foo这个值，并把它给我"
foo(2);
```


需要注意的是：我们经常会将函数声明 function foo(a) {...} 转化为普通的变量赋值（函数表达式） var foo = function(a) {…}，这样去理解的话，这个函数是 LHS 查询。但是有一个细微的差别，编译器可以在代码生成的同时处理声明和值的定义，比如引擎执行代码时，并不会有线程专门用来将一个函数值"分配给" foo，因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并不合适。


### LHS RHS 问题判别

``` console.log(b) ```

第一次对 b 进行 RHS 查询时是无法找到该变量的。也就是说，这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。 如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。值得注意的是，ReferenceError 是非常重要的异常类型。 

相较之下，当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量， 全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。 “不，这个变量之前并不存在，但是我很热心地帮你创建了一个。” ES5 中引入了“严格模式”。同正常模式，或者说宽松 / 懒惰模式相比，严格模式在行为上 有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。

因此，在 严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。
 
接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。 

ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的。




### 参考材料

- [https://segmentfault.com/a/1190000013126460](https://segmentfault.com/a/1190000013126460)
- [https://baike.baidu.com/item/编译型语言/9564109](https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80/9564109)
- [https://xiaozhuanlan.com/topic/1946507283](https://xiaozhuanlan.com/topic/1946507283)


