### js是解释型语言还是编译型语言？
### 编译型语言
代码在执行前需要预编译，转换成机器语言，运行时直接使用编译结果即可。

特点：

- 在编译过程中，会进行代码优化
- 编译后执行速度快，相比解释型对系统要求低
- 有专门的编译器
- 跨平台性不好 
   - 例如：比如c语言针对不同系统，需要编译成不同的机器语言(如windows编译成ext文件，linux编译成erp文件)，多个平台若多个版本，将非常难以维护。

### 解释型语言
代码在执行前不需要预先编译，在运行时必须先解释再执行。

特点：

- 再编译过程中，可能有优化但是较少
- 执行一次就要编译一次，速度较慢，效率比较低（JIT）
- 有专门的解释器：在源代码执行时被翻译成平台无关的中间代码，解释器会把这些代码翻译成机器语言
- 跨平台好 
   - 例如Java首先通过编译器编译成class文件，如果在windows平台上运行，将通过该平台的JVM进行解释，同理linux。所以说能跨平台，前提是平台上有匹配的JVM或者说是解释器。

### 各有利弊
对执行速度快，要求低的如操作系统，大型应用程序等，一般采用编译型语言。
对执行速度要求不高，平台兼容性高的程序，一般采用解释性语言，如Java、JS、PY

### 争端
对于JS的归属，一直都有争议：
> JavaScript ( JS ) 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言 - MDN
尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。- 你不知道的JS上


可以理解《你不知道的JS》的定论，因为JS的编译过程和传统的编译规程类似。
那么应该如何解释以下质疑：

1. 如果 JS 是解释型语言那为什么会有变量提升（hoisting）？
1. JIT（及时编译）会做代码优化(同时创建代码的编译版本)；解释型语言无法做到这些

解释：

1. 变量提升不是代码修改。在这个过程中没有生成中间代码。变量提升只是 JS 解释器处理事情的方式
1. JavaScript 代码需要在机器（node 或者浏览器）上安装一个工具（JS 引擎）才能执行。这是解释型语言需要的。编译型语言程序能够自由地直接运行。
1. JIT 是唯一一点我们可以对 JavaScript 是否是一个解释型语言提出疑问的理由。但是 JIT 不是完整的编译器，它在执行前进行编译。而且 JIT 只是 Mozilla 和 Google 的开发人员为了提升浏览器性能才引入的。JavaScript 或 TC39 从来没有强制要求使用 JIT。

### 拓展传统编译语言的流程

1.  分词/词法分析
这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代 码块被称为词法单元（token）。
1.  语法分析生成AST
这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST)
1.  生成代码
将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关 

### JS执行语句的过程

![v81](~@imgs/v81.jpeg)

![v82](~@imgs/v82.jpeg)

上图展示了V8引擎是如何工作的：

1. 词法分析
   1. scanner 是一个扫描器，用于对纯文本的 JavaScript 代码进行词法分析。它会将代码分析为 tokens

2. 语法分析
   1. parser 模块可以理解为是一个解析器。解析过程是一个语法分析的过程，它会将词法分析结果 tokens 转换为抽象语法树「Abstract Syntax Tree」，同时会验证语法，如果有错误就抛出语法错误。
   2. 预解析方案：
      1. 主流的 JavaScript 引擎都采用了**惰性解析**(Lazy Parsing)，因为源码在执行前如果全部完全解析的话，不仅会造成执行时间过长，而且会消耗更多的内存以及磁盘空间。
      2. **惰性解析就是指如果遇到并不是立即执行的函数，只会对其进行预解析(Pre-Parser)，当函数被调用时，才会对其完全解析。**
      3. 预解析时，只会验证函数的语法是否有效、解析函数声明以及确定函数作用域，并不会生成 AST，这项工作由 Pre-Parser 预解析器完成
   3. 预解析特点：
      - 预解析会跳过未被使用的代码
      - 不会生成 AST，会产生不带有变量引用和声明的 scopes 信息
      - 解析速度快
      - 根据规范抛出特定的错误
   - 全量解析特点：
      - 解析被使用的代码
      - 生成 AST
      - 构建具体的 scopes 信息，变量的引用，声明等
      - 抛出所有的语法错误

此时对应的，其实就是**执行上下文**的创建过程，关于执行上下文我们后续详细分析。需要区分的是，作用域与作用域链的信息是在预解析阶段就已经明确了。

3. 生成字节码
   1. Ignition 是 v8 提供的一个解释器。
   1. 他的作用是负责将抽象语法树 AST 转换为字节码。并且同时收集下一个阶段「编译」所需要的信息。这个过程，我们也可以理解为预编译过程。基于性能的考虑，预编译过程与编译过程有的时候不会区分的那么明显，有的代码在预编译阶段就能直接执行。

4. 编译器

TurboFan 是 v8 引擎的编译器模块。它会利用 Ignition 收集到的信息，将字节码转换为汇编代码。这也就是代码被最终执行的阶段。

Ignition + TurboFan 的组合，就是字节码解释器 + JIT 编译器的黄金组合「边解释边执行」。Ignition 收集大量的信息，交给 TurboFan 去优化，多方面条件都满足的情况下，会被优化成机器码，这个过程称为 Optimize，当判断无法优化时就会触发去优化「De-optimize」操作，这些代码逻辑会重新回到 Ignition 中称为字节码。

在这个过程中，有一个建议能够帮助我们避免去优化操作，从而提高代码执行效率。那就是**不要总是改变对象类型。**





### 参考材料

- [https://segmentfault.com/a/1190000013126460](https://segmentfault.com/a/1190000013126460)
- [https://baike.baidu.com/item/编译型语言/9564109](https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80/9564109)
- [https://xiaozhuanlan.com/topic/1946507283](https://xiaozhuanlan.com/topic/1946507283)
- [https://hungryturbo.com/pages/fa7f62/#%E7%BC%96%E8%AF%91%E5%99%A8-turbofan](https://hungryturbo.com/pages/fa7f62/#%E7%BC%96%E8%AF%91%E5%99%A8-turbofan)

