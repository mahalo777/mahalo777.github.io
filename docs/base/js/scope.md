
### 作用域重要概念

**为什么会有作用域？**

存储和访问变量的值的能力，将状态带给了程序，因此程序能执行复杂的任务。因此需要设计一套存储和查找变量的规则，这套规则就被称为作用域。

**作用域的概念**

作用域是存储和查找变量的规则


**词法作用域和动态作用域**

词法作用域和动态作用域是作用域的两种主要工作模型

词法作用域就是定义在词法阶段的作用域，由变量和块作用域写在哪里决定的。也就是说函数的作用域在函数定义的时候就决定了。

动态作用域是在函数调用的时候才决定的，是this的表亲。

```
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();

// 结果是 1
```

**作用域分类**

作用域分类|全局作用域 | 函数作用域 | 块作用域
---|---|---|---
对应变量|全局作用域 | 局部变量 | 块级变量
如何形成|默认 |函数 | let/const与{}、try catch、with


- var：有全局作用域和函数作用域，没有块作用域，有变量提升。在全局声明时创建window 对象的属性；能重复声明
- let、const：全局作用域、局部作用域、块作用域，有暂存性死区; let在for循环中每循环一次就会重新声明一次（因为let有块级作用域）

暂存性死区：

var的变量提升不同，通过 let 声明的变量直到它们的定义被执行时才初始化。在变量初始化前访问该变量会导致 `ReferenceError: Cannot access 'a' before initialization` 。该变量处在一个自块顶部到初始化处理的“暂存死区”中。尽管 a 发生了变量提升，但是在初始化赋值前(before initialization)不允许读取。

**提升**

1. 函数和变量的声明，会在代码执行前被提前处理。具体是引擎在编译阶段就会找到这些声明，并用合适的作用域将他们关联起来。也就会说作用域和作用域链在编译阶段已经被处理好了。
2. 函数会被优先提升，然后是变量。如果同名且函数声明在前，则同名变量会被视为重复声明，且忽略
3. 函数表达式不会被提升
4. 箭头函数没有自己的上下文，没有arguments，也不存在变量提升

**闭包**

-能够访问其他函数内部变量的函数，被称为 闭包。它的目的是局部数据的共享。

当函数记住并访问所在词法作用域时，即使在当前词法作用域外执行，就产生了闭包。

一个标准的闭包是：一组嵌套函数，内部函数访问了包装函数的变量等。然后内部函数的引用被return出去(或者SetTimeout，挂载在全局等)，在其他作用域被执行。

应用场景: 模拟私有属性或者静态变量、模拟模块化、柯里化、防抖和节流、Vue收集依赖、Redux、发布订阅模式

缺点: 早期浏览器不能被垃圾回收导致内存泄漏(ie9，现代浏览器没这个问题)、烧内存



**作用域链**

当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域

### 其他概念

**LHS RHS** 

引擎查找变量的方式。RHS 是 retrieve his source value，可理解成赋值操作的源头。LHS即赋值操作的目标。

ReferenceError 同作用域判别失败相关。TypeError 则代表作用域判别成功了，但是对结果的操作是不合法的。

**作用域嵌套**

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套

**作用域屏蔽**

在多层嵌套作用域中，可以定义同名的标识符。但作用域查找会在找到第一个匹配的标识符时停止，这叫遮蔽效应。

访问被同名遮蔽的全局可以Window.a

**欺骗词法**

词法作用域完全由函数所声明的位置来定义，但怎么进行修改或欺骗这种规则呢？

eval：传入一个包含声明的代码字符串，可以修改已经存在的词法作用域。
with：将一个对象的引用当做作用域处理，将对象的属性当做作用域的标识符处理，从而创建了一个新的词法作用域。

这两机制的副作用是引擎无法在编译时对作用域查找进行优化。



## 变量查找规则
补充了解即可

### LHS RHS

> 下面出自 你不知道的JS 上

那么 LHS 和 RHS 查询是什么呢？

这里的 L 代表左侧，R 代表右侧。通俗且不严谨的解释 LHS 和 RHS 的含义就是：当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。

那么描述的更准确的一点，RHS 查询与简单的查找某个变量的值毫无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。

从这个角度说，RHS 并不是真正意义上的"赋值操作的右侧"，更准确的说是"非左侧"。所以，我们可以将 RHS 理解成 Retrieve his source value（取到它的源值），这意味着，"得到某某的值"。

那我们来看一段代码深入理解一下 LHS 与 RHS。

```
function foo(a) {
  console.log(a);
}

foo(2);
```
在 ``console.log(a)`` 中，变量 a 的引用是一个 RHS 引用，因为我们是取到 a 的值。并将这个值传递给 console.log(…) 方法
相比之下，例如： a = 2 ，调用 foo(2) 时，隐式的进行了赋值操作。这里对 a 的引用就是 LHS 引用，因为我们实际上不关心当前的值时什么，只要想把 =2 这个赋值操作找到一个目标。

LHS 和 RHS 的含义是 赋值操作的左侧或右侧 并不一定意味着就是 = 赋值操作符的左侧或右侧。
赋值操作还有其他几种形式，因此在概念上最好将其理解 赋值操作的目标是谁（LHS） 以及 谁是赋值操作的源头（RHS）。

当然上面的程序并不只有一个 LHS 和 RHS 引用：

```
function foo(a) {
   // 这里隐式的进行了对形参 a 的 LHS 引用。

   // 这里对 log() 方法进行了 RHS 引用，询问 console 对象上是否有 log() 方法。
   // 对 log(a) 方法内的 a 进行 RHS 引用，取到 a 的值。
   console.log(a);
   // 2
}
// 此处调用 foo() 方法，需要调用对 foo 的 RHS 引用。意味着"去找foo这个值，并把它给我"
foo(2);
```


需要注意的是：我们经常会将函数声明 function foo(a) {...} 转化为普通的变量赋值（函数表达式） var foo = function(a) {…}，这样去理解的话，这个函数是 LHS 查询。但是有一个细微的差别，编译器可以在代码生成的同时处理声明和值的定义，比如引擎执行代码时，并不会有线程专门用来将一个函数值"分配给" foo，因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并不合适。


### LHS RHS 问题判别

``` console.log(b) ```

第一次对 b 进行 RHS 查询时是无法找到该变量的。也就是说，这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。 如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。值得注意的是，ReferenceError 是非常重要的异常类型。 

相较之下，当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量， 全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。 “不，这个变量之前并不存在，但是我很热心地帮你创建了一个。” ES5 中引入了“严格模式”。同正常模式，或者说宽松 / 懒惰模式相比，严格模式在行为上 有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。

因此，在 严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。
 
接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。 

ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的。
