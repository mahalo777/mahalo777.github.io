
## 执行上下文和作用域链

### 写在前面
由于网上文章杂乱，要注意ES版本。这里理解思路，并不纠结具体实现和版本更替。互联网上的文章，新，但不全，甚至不新。要注意分辨。

感觉JS解析和执行流程还是比较黑盒的，不像JVM，浏览器厂商就很多。再加上厂商实现效果可能和ES标准一致，但具体实现方法可能并不与规范一致。


### 概念

### 作用域
JS是词法作用域，词法作用域就是定义在词法阶段的作用域，由变量和块作用域写在哪里决定的。也就是说函数的作用域在函数定义的时候就决定了。

具体的，函数在创建的时候(预解析阶段)，会保存父级的所有变量对象指针到[[scope]] 属性中。注: 函数的 [[scope]] 属性并不是作用域链，详见下面说明。现代浏览器用内部属性是[[Scopes]]。ES本旧书一个规范，具体浏览器会实现效果，但内部结构、参数可能不同，所以是不是一个东西不纠结了。


### 执行上下文
当 Javascript 代码在运行的时候，它都是在执行上下文中运行。可理解为是当前代码的执行环境，且同一个函数在不同的环境中执行，会因为访问数据的不同产生不一样的结果。

分为三种：全局执行上下文、函数执行上下文、Eval函数执行上下文


### 执行上下文栈
what：执行上下文栈（Execution context stack，ECS），也叫函数调用栈(call stack)，是一种拥有LIFO（后进先出）数据结构的栈，用于存储代码执行时创建的执行上下文

why：由于JS是单线程的，每次只能做一件事情，通过这种机制，我们能够追踪到哪个函数正在执行，其他函数在调用栈中排队等待执行。保证了函数的调用顺序正确。

how：JS引擎第一次执行脚本时，会创建一个全局执行上下文压到栈顶，然后随着每次函数的调用都会创建一个新的执行上下文放入到栈顶中，随着函数执行完毕后被执行上下文栈顶弹出，直到回到全局的执行上下文中


### 作用域链
对于 JavaScript来说作用域及作用域链的**变量查询**是通过存储在浏览器内存中的执行上下文实现的。当查找变量时，首先从当前上下文中的变量对象查找，如果没有就会往上查找父级作用域中的变量对象，最终找到全局上下文的变量对象，如果没有就报错。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。（LHS&RHS？）




### 灵魂问答


#### 作用域和执行上下文有什么区别呢？
1. 作用域：作用域就是一个独立的区域，它可以让变量不会向外暴露出去。作用域最大的用处就是隔离变量。内层作用域可以访问外层作用域。作用域只是一个“地盘”，其中没有变量，要通过作用域对应的执行上下文环境来获取变量的。作用域在编译阶段就已经确定了，所以作用域是静态观念的，而执行上下文环境是动态的。
2. 执行上下文：一个作用域可能包含多个执行上下文，上下文是JS代码的运行环境。作用域变量的查找需要依赖执行上下文的变量对象。


#### 词法作用域和词法环境有什么区别呢？
1. 词法作用域是作用域的工作模型，它表示JS是静态作用域，在函数定义时根据位置确定的。相反的是动态作用域，类似this一样是动态的。
2. 词法环境是上下文的一部分，指代码块中标识符和变量值、函数值(内存地址)的关联关系。词环境内部包含环境记录器和对外部环境的引用。环境记录器是存储变量和函数声明的实际位置，对外部环境的引用意味着可以访问父级词法环境。

#### ES3执行上下文的Scope和函数内部属性[[scope]]有什么区别呢？

我们阅读过资料后发现，ES3创建执行上下文中也存在一个Scope，这与作用域划分时函数内部属性[[scope]]有什么关联呢？
参考下文的抽象数据结构：

```
const wrapper = () => {
  const inner = () => {
    // ...
  }
}

// 当函数创建时:
wrapper.[[scope]] = [
  gobalContext.VO
]

inner.[[scope]] = [
  wrapperContext.AO
  gobalContext.VO
]
```

后续执行 wrapper 函数创建执行上下文时(预编译阶段), 进入函数上下文并创建 VO/AO, 就会将活动对象添加到作用域顶端

```
wrapperContext = {
  AO: {}, // 活动对象: wrapper 函数的参数以及变量
  Scope: [AO, wrapper.[[scope]]] // !!! 这才是作用域链
}
```


关于 [[scope]] 和执行上下文中 Scope 的理解:
当你定义(书写)一个函数时, JS 引擎可以根据你书写的位置: 函数嵌套的位置, 生成一个[[scope]] 属性, 这个属性是属于函数的(即使函数不调用), 所以说基于词法作用域(静态的)
而 Scope 属性是在函数执行时, 生成执行上下文(VO/Scope/this), 这个是时候的 Scope 和 [[scope]] 不是同一个东西。Scope 是在 [[scope]] 的基础上新增了当前的 AO 对象来构成
所以函数定义时的[[scope]]是函数的属性, 函数执行时的 Scope 是执行上下文的属性。

```
Scope = [AO].concat([[Scope]]);
```

但这是ES3的处理，ES5标准以后使用VE/AE替换了VO/AO。

而ES5标准以后没有了Scope属性，增加了outer属性，应该也是类似的原理。可能是VO/AO变成了VE的词法环境和变量环境，所以设计需要变更，但outer指向上层执行上下文的词法环境，来获取执行过程中使用的变量，也可以理解为作用域链查找。


#### [[Scopes]]和[[scope]]有什么区别？
我们在浏览器中观察到函数内部属性[[Scopes]]，发现它和ES3的[[scope]]非常像，所以我们理解为不同版本就行。ps网上文章写啥的都有，不在这里计较了。



#### 那么[[Scopes]]和执行上下文的outer有什么关系呢？他们都是作用域链的实现吗？

[[Scopes]]和执行上下文的outer都是作用域链的实现，outer是ES规范的内容，[[Scopes]]是引擎的具体实现，效果一致但过程可能不一致。

[参考这里的解释](https://www.zhihu.com/question/505698662):

[[Scopes]]是收集调用栈列表。理论上说，这是规范中 contexts 的一种具体实现，与规范描述效果一致，但并不一定有规范内描述的所有内容。

比如具体 context 中用到 TaggedField + offset 偏移量来获取对应字段内容，而没有用到规范所描述的结构来实现。

看效果和ES3比较像。
补充图：


### 作用域链也是预解析阶段生成的吗？

不完全。在确认作用域时，作用域链的上游其实就确定了，只确认了一部分。只不过是在执行上下文创建/执行时，再将变量对象填入前面，这才是完整的作用域链。

[参考](https://www.zhihu.com/question/36751764)



### 执行上下文创建的时机？是词法分析阶段吗？


说法一：全量解析对应执行上下文的创建过程

引擎在解析时，分为懒解析(预解析)和全量解析，对于不会立刻执行的函数是懒解析，只会定义出作用域。

全量解析：它会解析所有立即执行的代码。
- 解析被使用的代码
- 生成 AST
- 构建具体的 scopes 信息，变量的引用，声明等
- 抛出所有的语法错误

此时对应的，其实就是执行上下文的创建过程。需要区分的是，作用域与作用域链的信息是在预解析阶段就已经明确了。

[参考](https://xiaozhuanlan.com/topic/1946507283)

说法二：

执行上下文是预解析阶段(v8具体哪个阶段呢？)，作用域在词法分析阶段确定的。

执行上下文是在函数体代码执行之前创建，在调用函数时赋值，函数调用结束时就会自动释放。因为不同的调用可能有不同的参数，导致产生不同的上下文。因此不会和作用域是同一时机。

个人比较认同看法二，上下文有三个重要属性: 变量对象/作用域链/this，有些在分词阶段不能确认。同时，不纠结的话，统一回答预解析阶段，具体细分后面研究（TODO）




### 执行上下文、提升、块作用域
块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。这也能说明在预解析阶段，定义了作用域范围，创建了执行上下文。

### 执行上下文、闭包
TODO

### 执行上下文过程展示
TODO




### ES3 ES5 ES2018(ES9)简介
- 执行上下文在 ES3 中，包含三个部分。
  1. scope：作用域，也常常被叫做作用域链。
  2. variable object：变量对象，用于存储变量的对象。
  3. this value：this 值。
- 在 ES5 中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。
  1. lexical environment：词法环境，当获取变量时使用, scope -> outer。
  2. variable environment：变量环境，当声明变量时使用, scope -> outer。
  3. this value：this 值。
- 在 ES2018 中，执行上下文又变成了这个样子，this 值被归入 lexical environment，但是增加了不少内容。
  1. lexical environment：词法环境，当获取变量或者 this 值时使用。
  2. variable environment：变量环境，当声明变量时使用
  3. code evaluation state：用于恢复代码执行位置。
  4. Function：执行的任务是函数时使用，表示正在被执行的函数。
  5. ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。
  6. Realm：使用的基础库和内置对象实例。
  7. Generator：仅生成器上下文有这个属性，表示当前生成器。





### 执行上下文解释作用域链、闭包、this
[翻译文章地址](https://zhuanlan.zhihu.com/p/460213025)
以往我们只是知道各个分散的概念，并不能串联起来，这个文章从执行上下文的角度解释了各个概念的由来。强推👍🏻

### 具体执行过程参考
[执行上下文](https://juejin.cn/post/7043408377661095967)

### 更详细的介绍
[详解每种](https://zhuanlan.zhihu.com/p/459759923)

### 其他参考
[执行上下文2](https://juejin.cn/post/6844904158957404167)
[执行上下文不同版本](https://juejin.cn/post/6945240902625394718#heading-12)

