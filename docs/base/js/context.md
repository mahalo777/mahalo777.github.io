
## 执行上下文和作用域链

### 写在前面
由于网上文章杂乱，要注意ES版本。这里理解思路，并不纠结具体实现和版本更替。互联网上的文章，新，但不全，甚至不新。要注意分辨。

感觉JS解析和执行流程还是比较黑盒的，不像JVM，浏览器厂商就很多。再加上厂商实现效果可能和ES标准一致，但具体实现方法可能并不与规范一致。


### 概念

### 作用域
JS是词法作用域，词法作用域就是定义在词法阶段的作用域，由变量和块作用域写在哪里决定的。也就是说函数的作用域在函数定义的时候就决定了。

具体的，函数在创建的时候(预解析阶段)，会保存父级的所有变量对象指针到[[scope]] 属性中。注: 函数的 [[scope]] 属性并不是作用域链，详见下面说明。现代浏览器用内部属性是[[Scopes]]。ES本旧书一个规范，具体浏览器会实现效果，但内部结构、参数可能不同，所以是不是一个东西不纠结了。


### 执行上下文
当 Javascript 代码在运行的时候，它都是在执行上下文中运行。可理解为是当前代码的执行环境，且同一个函数在不同的环境中执行，会因为访问数据的不同产生不一样的结果。

分为三种：全局执行上下文、函数执行上下文、Eval函数执行上下文


### 执行上下文栈
what：执行上下文栈（Execution context stack，ECS），也叫函数调用栈(call stack)，是一种拥有LIFO（后进先出）数据结构的栈，用于存储代码执行时创建的执行上下文

why：由于JS是单线程的，每次只能做一件事情，通过这种机制，我们能够追踪到哪个函数正在执行，其他函数在调用栈中排队等待执行。保证了函数的调用顺序正确。

how：JS引擎第一次执行脚本时，会创建一个全局执行上下文压到栈顶，然后随着每次函数的调用都会创建一个新的执行上下文放入到栈顶中，随着函数执行完毕后被执行上下文栈顶弹出，直到回到全局的执行上下文中


### 作用域链
对于 JavaScript来说作用域及作用域链的**变量查询**是通过存储在浏览器内存中的执行上下文实现的。当查找变量时，首先从当前上下文中的变量对象查找，如果没有就会往上查找父级作用域中的变量对象，最终找到全局上下文的变量对象，如果没有就报错。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。（LHS&RHS？）




### 灵魂问答


#### 作用域和执行上下文有什么区别呢？
1. 作用域：作用域就是一个独立的区域，它可以让变量不会向外暴露出去。作用域最大的用处就是隔离变量。内层作用域可以访问外层作用域。作用域只是一个“地盘”，其中没有变量，要通过作用域对应的执行上下文环境来获取变量的。作用域在编译阶段就已经确定了，所以作用域是静态观念的，而执行上下文环境是动态的。
2. 执行上下文：一个作用域可能包含多个执行上下文，上下文是JS代码的运行环境。作用域变量的查找需要依赖执行上下文的变量对象。
3.  执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。

#### 词法作用域和词法环境有什么区别呢？
1. 词法作用域是作用域的工作模型，它表示JS是静态作用域，在函数定义时根据位置确定的。相反的是动态作用域，类似this一样是动态的。
2. 词法环境是上下文的一部分，指代码块中标识符和变量值、函数值(内存地址)的关联关系。词环境内部包含环境记录器和对外部环境的引用。环境记录器是存储变量和函数声明的实际位置，对外部环境的引用意味着可以访问父级词法环境。

#### ES3执行上下文的Scope和函数内部属性[[scope]]有什么区别呢？

我们阅读过资料后发现，ES3创建执行上下文中也存在一个Scope，这与作用域划分时函数内部属性[[scope]]有什么关联呢？
参考下文的抽象数据结构：

```
const wrapper = () => {
  const inner = () => {
    // ...
  }
}

// 当函数创建时:
wrapper.[[scope]] = [
  gobalContext.VO
]

inner.[[scope]] = [
  wrapperContext.AO
  gobalContext.VO
]
```

后续执行 wrapper 函数创建执行上下文时(预编译阶段), 进入函数上下文并创建 VO/AO, 就会将活动对象添加到作用域顶端

```
wrapperContext = {
  AO: {}, // 活动对象: wrapper 函数的参数以及变量
  Scope: [AO, wrapper.[[scope]]] // !!! 这才是作用域链
}
```


关于 [[scope]] 和执行上下文中 Scope 的理解:
当你定义(书写)一个函数时, JS 引擎可以根据你书写的位置: 函数嵌套的位置, 生成一个[[scope]] 属性, 这个属性是属于函数的(即使函数不调用), 所以说基于词法作用域(静态的)
而 Scope 属性是在函数执行时, 生成执行上下文(VO/Scope/this), 这个是时候的 Scope 和 [[scope]] 不是同一个东西。Scope 是在 [[scope]] 的基础上新增了当前的 AO 对象来构成
所以函数定义时的[[scope]]是函数的属性, 函数执行时的 Scope 是执行上下文的属性。

```
Scope = [AO].concat([[Scope]]);
```

但这是ES3的处理，ES5标准以后使用VE/AE替换了VO/AO。

而ES5标准以后没有了Scope属性，增加了outer属性，应该也是类似的原理。可能是VO/AO变成了VE的词法环境和变量环境，所以设计需要变更，但outer指向上层执行上下文的词法环境，来获取执行过程中使用的变量，也可以理解为作用域链查找。


#### [[Scopes]]和[[scope]]有什么区别？
我们在浏览器中观察到函数内部属性[[Scopes]]，发现它和ES3的[[scope]]非常像，所以我们理解为不同版本就行。ps网上文章写啥的都有，不在这里计较了。



#### 那么[[Scopes]]和执行上下文的outer有什么关系呢？他们都是作用域链的实现吗？

[[Scopes]]和执行上下文的outer都是作用域链的实现，outer是ES规范的内容，[[Scopes]]是引擎的具体实现，效果一致但过程可能不一致。

[参考这里的解释](https://www.zhihu.com/question/505698662):

[[Scopes]]是收集调用栈列表。理论上说，这是规范中 contexts 的一种具体实现，与规范描述效果一致，但并不一定有规范内描述的所有内容。

比如具体 context 中用到 TaggedField + offset 偏移量来获取对应字段内容，而没有用到规范所描述的结构来实现。

看效果和ES3比较像。
补充图：


### 作用域链也是预解析阶段生成的吗？

不完全。在确认作用域时，作用域链的上游其实就确定了，只确认了一部分。只不过是在执行上下文创建/执行时，再将变量对象填入前面，这才是完整的作用域链。

[参考](https://www.zhihu.com/question/36751764)



### 执行上下文创建的时机？是词法分析阶段吗？


说法一：全量解析对应执行上下文的创建过程

引擎在解析时，分为懒解析(预解析)和全量解析，对于不会立刻执行的函数是懒解析，只会定义出作用域。

全量解析：它会解析所有立即执行的代码。
- 解析被使用的代码
- 生成 AST
- 构建具体的 scopes 信息，变量的引用，声明等
- 抛出所有的语法错误

此时对应的，其实就是执行上下文的创建过程。需要区分的是，作用域与作用域链的信息是在预解析阶段就已经明确了。

[参考](https://xiaozhuanlan.com/topic/1946507283)

说法二：

执行上下文是预解析阶段(v8具体哪个阶段呢？)，作用域在词法分析阶段确定的。

执行上下文是在函数体代码执行之前创建，在调用函数时赋值，函数调用结束时就会自动释放。因为不同的调用可能有不同的参数，导致产生不同的上下文。因此不会和作用域是同一时机。


说法三：

预编译(函数执行前)※
1. 创建AO对象（Active Object）
2. 查找函数形参及函数内变量声明，形参名及变量名作为AO对象的属性，值为undefined
3. 实参形参相统一，实参值赋给形参
4. 查找函数声明，函数名作为AO对象的属性，值为函数引用

预编译(脚本代码块script执行前)
1. 查找全局变量声明（包括隐式全局变量声明，省略var声明），变量名作全局对象的属性，值为undefined
3. 查找函数声明，函数名作为全局对象的属性，值为函数引用


总结来看：全局上下文的创建和作用域的确定可能有重合时机，而造成一的理解，但函数上下文的创建和作用域确认并不在一个细分时机。
 同时上下文包含：变量对象/作用域链/this，有些在分词阶段不能确认。同时，不纠结的话，统一回答预解析阶段，具体细分后面研究（TODO）



### 从执行上下文理解提升、TDZ、块作用域
[参考译文](https://zhuanlan.zhihu.com/p/459759923)

块作用域：

块级作用域就是通过词法环境的栈结构来实现的。当在块作用域中看到由 let 和 const 声明的变量时，JavaScript 为我们创建了一个单独的区域。词法环境为这些变量维护着一个类似于栈的结构。所以同名的 let 变量不会相互冲突。

在查找变量时：
- 词法环境：从栈顶从上到下->变量环境->outer
- 变量环境：变量环境->outer 

提升：

注意：你可能已经注意到了，在创建阶段 let 和 const 变量为 uninitialized，而 var变量为 undefined。

这是因为在创建阶段，代码被扫描为变量和函数声明，而函数声明被完整的存储在环境中，变量最初被设置为 undefined（var）或者保持 uninitiated（let 和 const）。

这就是为什么你可以在声明前访问 var 定义的变量（尽管是 undefined），但是在声明前访问 let 和 const 变量时会出现引用错误的原因。

这就是我们所说的变量“提升”。


TDZ：

- 对于 var 变量来说，它的创建和初始化是被提升的，但赋值不是。
- 对于 let 变量来说，它的创建是被提升的，但是初始化和赋值不是。
- 对于函数来说，它的创建、初始化和赋值同时被提升。
人们将变量初始化之前的代码阶段称为暂时死区（temporal dead zone TDZ）。
- 如果你试图在创建之前访问变量，你会看到错误“[variable name] is not defined.”
- 如果你希望在初始化之前访问变量，你会看到错误“Cannot access [variable name] before initialization.”
- 如果你在赋值之前使用一个变量，你会看到 undefined



### 从执行上下文理解闭包和this


this: 每个作用域都有自己的this，但this与任何作用域概念都无关。

[参考这里的闭包、this](https://zhuanlan.zhihu.com/p/460213025)


闭包：
外包裹函数wrapper执行完后，上下文所有内容被从执行栈移除。当我们在外部，调用内部的函数引用innner时，词法作用域规则发挥作用——内部函数可以访问外部函数中的变量。根据规则，**引用的变量**被保存到一个单独的区域。这是一个只能由内部的函数inner 访问的专属区域，也被称为闭包。
- 只有被引用的变量被闭包包含，不是wrapper所有的变量。
- 闭包在调试中可以在函数的[[Scopes]]观察，一般是[{闭包使用的变量}, {父级作用域内容(上下文的VO)}]
- 闭包在JS引擎的内存中存储，具体点可能是堆？

TODO
[探索V8中的闭包](https://zhuanlan.zhihu.com/p/469049684)
[v8内存管理](https://zhuanlan.zhihu.com/p/470643126)





### ES3 ES5 ES2018(ES9)版本变迁

- 执行上下文在 ES3 中，包含三个部分。
  - scope：作用域链
  - variable object：变量对象
  - this value：this 
- 在 ES5 增加了词法环境：
  - lexical environment：词法环境，存储函数声明和使用 let const 关键字绑定的变量，以此来实现函数级作用域
  - variable environment：存储 var 声明的变量
  - this value：this 值。
  - 词法/变量环境包含两部分：
    - 环境记录：存储变量和函数声明的实际位置
    - 对外部环境的引用：它指向作用域链的下一个对象，可以访问其父级词法环境（作用域），作用与 es3 的作用域链相似， scope -> outer
- 在 ES2018 this被归入词法环境，同时增加了新内容：
  - lexical environment
  - variable environment
  - code evaluation state：用于恢复代码执行位置。
  - Function：执行的任务是函数时使用，表示正在被执行的函数。
  - ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。
  - Realm：使用的基础库和内置对象实例。
  - Generator：仅生成器上下文有这个属性，表示当前生成器。
  - 

#### ES3上下文执行过程
对于 ES3 中的执行上下文，我们可以用下面这个列表来概括程序执行的整个过程：

1. 函数被调用
2. 在执行具体的函数代码之前，创建了执行上下文
3. 进入执行上下文的创建阶段：
    - 初始化作用域链
    - 创建 arguments object 检查上下文中的参数，初始化名称和值并创建引用副本
扫描上下文找到所有函数声明：

        - 对于每个找到的函数，用它们的原生函数名，在变量对象中创建一个属性，该属性里存放的是一个指向实际内存地址的指针
        - 如果函数名称已经存在了，属性的引用指针将会被覆盖

    - 扫描上下文找到所有 var 的变量声明：

        - 对于每个找到的变量声明，用它们的原生变量名，在变量对象中创建一个属性，并且使用 undefined 来初始化
        - 如果变量名作为属性在变量对象中已存在，则不做任何处理并接着扫描


4. 确定 this 值
5. 进入执行上下文的执行阶段：
    在上下文中运行/解释函数代码，并在代码逐行执行时分配变量值。



#### ES5


对于 ES5 中的执行上下文，我们可以用下面这个列表来概括程序执行的整个过程：
1. 程序启动，全局上下文被创建
    -  创建全局上下文的 词法环境
        - 创建 对象环境记录器 ，它用来定义出现在 全局上下文 中的变量和函数的关系（负责处理 let 和 const 定义的变量）
        - 创建 外部环境引用，值为 null
    - 创建全局上下文的 变量环境
        - 创建 对象环境记录器，它持有 变量声明语句 在执行上下文中创建的绑定关系（负责处理 var 定义的变量，初始值为 undefined 造成声明提升）
        - 创建 外部环境引用，值为 null
    - 确定 this 值为全局对象（以浏览器为例，就是 window ）
2. 函数被调用，函数上下文被创建 
      - 创建函数上下文的 词法环境
         - 创建 声明式环境记录器 ，存储变量、函数和参数，它包含了一个传递给函数的 arguments 对象（此对象存储索引和参数的映射）和传递给函数的参数的 length。（负责处理 let 和 const 定义的变量）
         - 创建 外部环境引用，值为全局对象，或者为父级词法环境（作用域）
      - 创建函数上下文的 变量环境
        - 创建 声明式环境记录器 ，存储变量、函数和参数，它包含了一个传递给函数的 arguments 对象（此对象存储索引和参数的映射）和传递给函数的参数的 length。（负责处理 var 定义的变量，初始值为 undefined 造成声明提升）
        - 创建 外部环境引用，值为全局对象，或者为父级词法环境（作用域）
      - 确定 this 值
3. 进入函数执行上下文的执行阶段： 
  在上下文中运行/解释函数代码，并在代码逐行执行时分配变量值。


#### 执行过程
[傻傻分不清之作用域/执行上下文](https://caraws.github.io/2022/03/21/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/)
[框架很好](https://juejin.cn/post/6956827007296471070#heading-6)
[两个版本执行过程参考](https://juejin.cn/post/6844904158957404167#heading-12)
[上下文的函数案例很好](https://juejin.cn/post/6945240902625394718#heading-2)


### 开始串联

#### JS引擎

### 结合执行栈解释
https://www.cnblogs.com/MomentYY/p/15785719.html TODO

### 从打开一个tab到执行代码，从盘古开天辟地写起

在一个晴朗的周末，你想打开网站学习一会，那么这个过程发生了什么呢？


由于进程有自己的专用内存空间，因此进程通常包含通用基础架构的副本（例如，V8，这是 Chrome 的 JavaScript 引擎）。这意味着内存使用量更高，因为它们不能像它们是同一进程中的线程时那样共享。为了节省内存，Chrome 对可以启动的进程数量设置了限制。 该上限因设备的内存和 CPU 性能而异，但当 Chrome 达到上限时，便会开始在一个进程中运行来自同一网站的多个标签页。


浏览器进程： 标签页以外的一切都由浏览器进程处理。浏览器进程具有如下线程：用于绘制浏览器的按钮和输入字段的界面线程、负责处理网络堆栈以从互联网接收数据的网络线程、用于控制文件访问的存储线程等。当您在地址栏中输入网址时，输入由浏览器进程的界面线程处理。



    1. 你打开了浏览器，操作系统为浏览器创建了一个进程，为进程分配内存等资源，然后加入进程队列中执行。然后你就看到浏览器的UI界面了。

    2.浏览器为你新开了一个tab，同时这是一个单独渲染进程(renderer process)。

    https://developer.chrome.com/blog/inside-browser-part2?hl=zh-cn
    
        - 处理输入：你在地址栏输入网址，浏览器进程的界面线程为你判断是转到网址还是搜索引擎。
        - 开始导航：当你点击 Enter 键时，界面线程会发起网络调用来获取网站内容。标签页的一角会显示“正在加载”旋转图标，并且网络线程会通过适当的协议（例如 DNS 查找）并为请求建立 TLS 连接。（网络这里可以拓展连接过程，不属于本文重点讨论内容就不赘述了，在附录中见）
        - 处理响应：网络线程会查看响应流的响应头：如果响应是 HTML 文件，下一步就是将数据传递给渲染程序进程；但如果它是 ZIP 文件或其他某个文件，则意味着它是一个下载请求，所以它们需要将数据传递给下载管理器。
        - 查找渲染进程：在完成所有安全检查且网络线程确信浏览器应导航到所请求的网站后，网络线程会告知界面线程数据已准备就绪。然后，界面线程会找到渲染程序进程来继续渲染网页。
        - 提交导航：现在数据和渲染程序进程已准备就绪，浏览器进程会向渲染器进程发送 IPC 以提交导航。它还会传递数据流，以便渲染程序进程可以继续接收 HTML 数据。浏览器进程听到在渲染程序进程中发生提交的确认信息后，文档加载阶段随即开始，导航就完成了，此时访问记录也被记录在磁盘中。
        - 开始渲染
        - 提交导航后，渲染器进程会继续加载资源并渲染页面。我们会在下面介绍。渲染程序进程“完成”渲染后，会将 IPC 发送回浏览器进程（在网页中的所有帧上触发所有 onload 事件并完成执行后）。此时，界面线程会停止标签页上的加载旋转图标。
    3. 渲染进程处理网页内容。渲染程序进程的核心任务是将 HTML、CSS 和 JavaScript 转换为用户可与之互动的网页。
        - 解析：当渲染器进程收到导航的提交消息并开始接收 HTML 数据时，主线程开始解析文本字符串 (HTML)，并将其转换为一个对象模态 (DOM)。
            - 网站通常使用图片、CSS 和 JavaScript 等外部资源。为了加快速度，系统会并发运行“预加载扫描程序”。如果 HTML 文档中包含 <img> 或 <link> 等内容，预加载扫描器会查看由 HTML 解析器生成的令牌，并将请求发送到浏览器进程中的网络线程
            - JS阻塞：当 HTML 解析器找到 <script> 标记时，它会暂停解析 HTML 文档，并必须加载、解析并执行 JavaScript 代码。因为JS内容可能会改变DOM
            - 遇到JS解析时，应该请求v8了，这里下面在写
            
        - 样式计算：主线程解析 CSS 并确定为每个 DOM 节点计算出的样式。优先级：提供的CSS > 浏览器默认样式表
        - 布局：布局是查找元素几何形状的过程。主线程会遍历 DOM 和计算出的样式，并创建包含 x y 坐标和边界框大小等信息的布局树。
        - 绘制：在绘制步骤中，主线程遍历布局树，创建绘制记录。绘制记录是绘图过程的记录，就像是“背景优先，然后是文本，然后是矩形”。
        - 合成：现在，浏览器已经知道文档的结构、每个元素的样式、页面的几何图形和绘制顺序，接下来该如何绘制页面呢？将这些信息转换为屏幕上的像素就称为光栅化。
            - 什么是合成？合成是一种技术，可将页面的各个部分分离成图层，单独将其光栅化，然后在单独的线程（称为合成器线程）中合成为页面。如果发生滚动，由于图层已经光栅化，您只需合成一个新帧即可。通过移动层和合成新帧，可以采用相同的方式实现动画。
            - 遍历布局树生成层树，layout-tree -> layer tree：为了找出哪些元素需要位于哪些层，主线程会遍历布局树来创建层树（此部分在开发者工具的“性能”面板中称为“更新层树”）
            - 主线程以外的光栅图像和合成图像：图层树创建完毕并确定绘制顺序后，主线程会将该信息提交到合成器线程。然后，合成器线程会光栅化每个图层。图层可能像页面的整个长度一样大，因此合成器线程会将其划分为图块，并将每个图块发送到光栅线程。光栅线程会光栅化每个图块并将其存储在 GPU. 创建图块位图并将其发送到 GPU 的光栅线程 内存中。合成器线程可以优先处理不同的光栅线程，以便首先对视口（或附近）中的内容进行光栅化。一个图层还具有多个适用于不同分辨率的平铺，以处理放大操作等任务。
            将图块进行光栅化后，合成器线程会收集称为“绘制四边形”的图块信息，以创建合成器帧。
            然后通过 IPC 将合成器帧提交到浏览器进程。此时，对于浏览器界面更改，可以从界面线程添加另一个合成器帧.这些合成器帧会发送到 GPU 以在屏幕上显示。如果滚动事件传入，合成器线程会创建另一个要发送到 GPU 的合成器帧。
        - 监听用户动作合成新的帧
            - 当发生用户手势（如轻触屏幕）时，浏览器进程是最先收到该手势的进程。不过，浏览器进程只会知道该手势的发生位置，因为标签页中的内容是由渲染程序进程处理的。因此，浏览器进程会将事件类型（例如 touchstart）及其坐标发送到渲染程序进程。渲染程序进程通过查找事件目标并运行附加的事件监听器来适当地处理事件。
            - 我们了解了合成器如何通过合成光栅化图层来流畅地处理滚动。如果页面未附加任何输入事件监听器，合成器线程可以完全独立于主线程创建新的复合帧。但是，如果页面中附加了一些事件监听器，该怎么办？合成器线程如何确定是否需要处理该事件？
            - 由于运行 JavaScript 是主线程的作业，因此在合成页面时，合成器线程会将附加了事件处理程序的页面区域标记为“非快速滚动区域”。有了这些信息，合成器线程可以确保在输入事件发生时将该输入事件发送到主线程。如果输入事件来自此区域之外，则合成器线程会继续合成新帧，而不会等待主线程
            - 由于您只需为所有元素编写一个事件处理脚本，因此此事件委托模式的工效学设计非常具有吸引力。不过，如果您从浏览器的角度查看此代码，就会发现整个页面现在会被标记为非快速滚动区域。这意味着，即使应用并不关注来自页面某些部分的输入，合成器线程也必须与主线程通信，并在每次有输入事件传入时等待。因此，合成器的流畅滚动功能会受到影响。
            - 为避免发生这种情况，您可以在事件监听器中传递 passive: true 选项。这会提示浏览器您仍想监听主线程中的事件，但合成器也可以继续合成新帧。
        
        
    - JS解析过程
        - 初始化宿主宿主环境和V8：一个浏览器可以有多个渲染进程。通常每个浏览器的标签都会有一个渲染进程，并初始化一个 V8 实例。
        Call Stack（调用栈）
        Heap（堆）
        Callback Queue（回调队列）
        Event Loop（事件循环）
        Web API 和 Web DOM
        - HTML 解析器在遇到 script 标签时，标签中的源代码会从网络（network）、缓存（cache）或者已经安装的 Service Worker 中加载。脚本代码以字节流的形式被响应，所以会由字节流解码器（byte stream decoder）来处理。字节流解码器对正在下载的字节流进行解码。字节流解码器从解码的字节中创建出许多 Token。比如：

        0066 解码为 f
        0075 解码为 u
        006e 解码为 n
        0063 解码为 c
        0074 解码为 t
        0069 解码为 i
        006f 解码为 o
        这就是 function，JavaScript 中它是一个保留关键字（keyword），这时候一个 Token 就创建好了，然后它会被发送到解析器（parser）。其他字节流也像这样被处理（这里没有提及预编译器（pre-parser），我们会在文章后面的内容中介绍
        - 解析器会根据传过来的 Token 数组创建节点（node）。通过这些节点，会创建出抽象语法树（Abstract Syntax Tree AST） 。
        - 解释器遍历 AST，并根据 AST 中包含的信息生成字节码（byte code）
        - 字节码、连同生成的类型反馈信息，被发送到优化编译器（optimizing compiler）。优化编译器接收到字节码和类型反馈信息后，将会生成高度优化的机器码（machine code） 。
        - 编译和执行机器码
        - JIT
        
    - JS执行过程
        - 分词阶段确认了作用域
        - 创建全局上下文
            - 初始化全局上下文对象，放入执行栈
            - 初始化全局方法和类，比如Math、Date等
            - 收集全局定义的变量和函数，并进行初始化
            - this/window指向全局对象自身
        - 执行全局代码块
            - 全局变量赋值
            - 遇到嵌套函数
        - 创建函数执行上下文
            - 函数执行上下赋值
            - 执行代码，结束后移出执行栈
        -解释执行
        
        
            
