(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{427:function(t,e,a){"use strict";a.r(e);var r=a(56),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("读完本文希望你能了解：")]),t._v(" "),a("ul",[a("li",[t._v("浏览器的架构、线程、进程")]),t._v(" "),a("li",[t._v("浏览器一次导航背后发生了什么")]),t._v(" "),a("li",[t._v("概念的关联：浏览器内核、JS引擎、线程、进程")]),t._v(" "),a("li",[t._v("V8是如何工作的")])]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.yuque.com/hebingqian/sd5tn0/kifd3i",target:"_blank",rel:"noopener noreferrer"}},[t._v("本人原文原址，懒得搬图片了"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"浏览器架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器架构"}},[t._v("#")]),t._v(" 浏览器架构")]),t._v(" "),a("blockquote",[a("p",[t._v("硬件、操作系统、软件的分层架构\n浏览器是如何划分模块的，并且分配进程或线程给这些模块运行")])]),t._v(" "),a("h3",{attrs:{id:"cpu、gpu、操作系统、应用的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu、gpu、操作系统、应用的关系"}},[t._v("#")]),t._v(" CPU、GPU、操作系统、应用的关系")]),t._v(" "),a("p",[a("strong",[t._v("CPU")]),t._v(" 即中央处理器，可以处理几乎所有计算。以前的 CPU 是单核的，现在大部分笔记电脑都是多核的，专业服务器甚至有高达 100 多核的。CPU 计算能力很强，但只能一件件事处理。\n**GPU **一开始是为图像处理设计的，即主要处理像素点，所以拥有大量并行的处理简单事物的能力，非常适合用来做矩阵运算，而矩阵运算又是计算机图形学的基础，所以大量用在可视化领域。\n"),a("strong",[t._v("CPU、GPU 都是计算机硬件，这些硬件各自都提供了一些接口供汇编语言调用；而操作系统则基于它们之上用 C 语言（或其它）将硬件管理了起来，包括进程调度、内存分配、用户内核态切换等等；运行在操作系统之上的则是应用程序了，所以应用程序不直接和硬件打交道，而是通过操作系统间接操作硬件。")]),t._v(" "),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/1352188/1650771326874-8ad75fb4-af0e-4bbd-90f6-a20d0e421bcb.png#clientId=ucc3b312a-f2a8-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=353&id=u8e66eb01&margin=%5Bobject%20Object%5D&name=jiagou.png&originHeight=470&originWidth=756&originalType=binary&ratio=1&rotation=0&showTitle=false&size=128057&status=done&style=none&taskId=u064bd5ba-fddd-45c7-a1a9-f722db19e35&title=&width=567",alt:"jiagou.png"}})]),t._v(" "),a("blockquote",[a("p",[t._v("为什么应用程序不能直接操作硬件呢？\n这样做有巨大的安全隐患，因为硬件是没有任何抽象与安全措施的，这意味着理论上一个网页可以通过 js 程序，在你打开网页时直接访问你的任意内存地址，读取你的聊天记录，甚至读取历史输入的银行卡密码进行转账操作。")])]),t._v(" "),a("h3",{attrs:{id:"在进程和线程上执行程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在进程和线程上执行程序"}},[t._v("#")]),t._v(" 在进程和线程上执行程序")]),t._v(" "),a("p",[t._v("为了让程序运行的更安全，操作系统创造了进程与线程的概念，进程可以分配独立的内存空间，进程内可以创建多个线程进行工作，这些线程共享内存空间。\n因为线程间共享内存空间，因此不需通信就能交流，但内存地址相互隔离的进程间也有通信需求，需通过 "),a("strong",[t._v("IPC")]),t._v("（Inter Process Communication）进行通信。\n"),a("strong",[t._v("进程之间相互独立，即一个进程挂了不会影响到其它进程，还可以一个进程中可以创建一个新进程，并与之通信，所以浏览器就采用了这种策略，将 UI、网络、渲染、插件、存储等模块进程独立，并且任意挂掉后都可以被重新唤起。")]),t._v(" "),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/svg/1352188/1650779046121-2f0763fa-8e13-4215-9908-a381ec901a9f.svg#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5182df5f&margin=%5Bobject%20Object%5D&name=get.svg&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=252656&status=done&style=none&taskId=ub57c1cac-ecb7-4087-b206-b573be1ce26&title=",alt:"get.svg"}}),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/svg/1352188/1650771595568-7f1ccda4-085b-462f-85ed-93ef41c543ee.svg#clientId=ucc3b312a-f2a8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufc4bcb5d&margin=%5Bobject%20Object%5D&name=1.svg&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=293505&status=done&style=none&taskId=u7d816ed0-2752-44df-b601-299174d6d4b&title=",alt:"1.svg"}})]),t._v(" "),a("h3",{attrs:{id:"浏览器有哪些进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器有哪些进程"}},[t._v("#")]),t._v(" 浏览器有哪些进程")]),t._v(" "),a("p",[t._v("下表展示每个 Chrome 进程与各自控制的内容：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[a("strong",[t._v("进程")])]),t._v(" "),a("th",[a("strong",[t._v("控制")])])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Browser进程")]),t._v(" "),a("td",[t._v("负责浏览器页面显示，与用户交互，如前进后退等。负责各个页面的管理，创建和销毁其它进程。")])]),t._v(" "),a("tr",[a("td",[t._v("Renderer进程")]),t._v(" "),a("td",[t._v("控制标签页内网站展示。默认每个Tab一个进程，内部是多线程的。")])]),t._v(" "),a("tr",[a("td",[t._v("Plugin")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("进程")]),t._v(" "),a("td",[t._v("控制站点使用的任意插件，如 Flash。")])]),t._v(" "),a("tr",[a("td",[t._v("GPU")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("进程")]),t._v(" "),a("td",[t._v("处理独立于其它进程的 GPU 任务。GPU 被分成不同进程，因为 GPU 处理来自多个不同应用的请求并绘制在相同表面。")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/1352188/1650780058913-1eeba5d0-aa9c-4232-a80f-940e52bdd9a8.png#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=drop&height=216&id=dGNJR&margin=%5Bobject%20Object%5D&name=mianProcess.png&originHeight=431&originWidth=768&originalType=binary&ratio=1&rotation=0&showTitle=false&size=107438&status=done&style=none&taskId=ucbc5a867-1072-483e-9221-851d37de4f8&title=&width=384",alt:"mianProcess.png"}}),t._v("\n图 9：不同进程指向浏览器 UI 的不同部分\n还有更多进程如扩展进程与应用进程。如果你想要了解有多少进程运行在你的 Chrome 浏览器中，可以点击右上角的选项菜单图标，选择更多工具，然后选择任务管理器。然后会打开一个窗口，其中列出了当前正在运行的进程以及它们当前的 CPU/内存使用量。")]),t._v(" "),a("h3",{attrs:{id:"浏览器架构-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器架构-2"}},[t._v("#")]),t._v(" 浏览器架构")]),t._v(" "),a("p",[t._v("那么浏览器是怎么使用进程和线程来工作的呢？\n其实大概可以分为两种架构，一种是"),a("strong",[t._v("单进程架构，"),a("strong",[t._v("也就是只启动一个进程，这个进程里面有多个线程工作。\n第二种是")]),t._v("多进程架构")]),t._v("，浏览器会启动多个进程，每个进程里面有多个线程，不同进程通过IPC进行通信。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/1352188/1650779578339-7eb223e9-e2af-4885-ac33-fecbfc5bb32f.png#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=drop&height=143&id=u009d9f10&margin=%5Bobject%20Object%5D&name=jiagoux.png&originHeight=286&originWidth=747&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82394&status=done&style=none&taskId=ufb56d518-1f75-44db-a4c8-dfbabc6dd2f&title=&width=374",alt:"jiagoux.png"}}),t._v("\n以chrome举例：\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/1352188/1650779737809-7bd4b615-7959-4eed-887b-aa11df2c163a.png#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=drop&height=245&id=uf759949d&margin=%5Bobject%20Object%5D&name=chrome.png&originHeight=490&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115552&status=done&style=none&taskId=ufb0d1d44-6b92-451f-9e76-ae08b50afe2&title=&width=375",alt:"chrome.png"}}),t._v("\nChrome浏览器会有一个浏览器进程（browser process），这个进程会和其他进程一起协作来实现浏览器的功能。对于渲染进程（renderer process），Chrome会尽可能为每一个tab甚至是页面里面的每一个iframe都分配一个单独的进程。")]),t._v(" "),a("h3",{attrs:{id:"chrome-多进程架构的优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chrome-多进程架构的优缺点"}},[t._v("#")]),t._v(" Chrome 多进程架构的优缺点")]),t._v(" "),a("p",[a("strong",[t._v("优点：")])]),t._v(" "),a("ul",[a("li",[t._v("避免单个page crash影响整个浏览器")]),t._v(" "),a("li",[t._v("避免第三方插件crash影响整个浏览器")]),t._v(" "),a("li",[t._v("多进程充分利用多核优势")]),t._v(" "),a("li",[t._v("方便使用沙盒模型隔离插件等进程，提高浏览器稳定性")])]),t._v(" "),a("p",[a("strong",[t._v("缺点：占内存")]),t._v("。\n由于进程有自己的私有内存空间，所以它们通常包含公共基础设施的拷贝(如 V8)。这意味着使用了更多的内存，如果它们不是同一进程中的线程，就无法共享这些拷贝。\n为了节省内存，Chrome 对可启动的进程数量有所限制。具体限制数值依设备可提供的内存与 CPU 能力而定，但是当 Chrome 运行时达到限制时，会开始在同一站点的不同标签页上运行同一进程。")]),t._v(" "),a("h3",{attrs:{id:"节省更多内存-chrome-中的服务化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节省更多内存-chrome-中的服务化"}},[t._v("#")]),t._v(" 节省更多内存 —— Chrome 中的服务化")]),t._v(" "),a("p",[t._v("Chrome 正在经历架构变革，它转变为将浏览器程序的每一模块作为一个服务来运行，从而可以轻松实现进程的拆解或聚合。\n浏览器有许多独立的模块(进程和线程)，比如：")]),t._v(" "),a("ul",[a("li",[t._v("浏览器模块（Browser）：负责整个浏览器内行为协调，调用各个模块。")]),t._v(" "),a("li",[t._v("网络模块（Network）：负责网络 I/O。")]),t._v(" "),a("li",[t._v("存储模块（Storage）：负责本地 I/O。")]),t._v(" "),a("li",[t._v("用户界面模块（UI）：负责浏览器提供给用户的界面模块。")]),t._v(" "),a("li",[t._v("GPU 模块：负责绘图。")]),t._v(" "),a("li",[t._v("渲染模块（Renderer）：负责渲染网页。")]),t._v(" "),a("li",[t._v("设备模块（Device）：负责与各种本地设备交互。")]),t._v(" "),a("li",[t._v("插件模块（Plugin）：负责处理各类浏览器插件。")])]),t._v(" "),a("p",[t._v("通常观点是当 Chrome 运行在强力硬件上时，它会将每个服务分解到不同进程中，从而提升稳定性，但是如果 Chrome 运行在资源有限的设备上时，它会将服务聚合到一个进程中从而节省了内存占用。在这一架构变革实现前，类似的整合进程以减少内存使用的方法已经在 Android 类平台上使用。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/svg/1352188/1650780464833-033b0d7d-cb17-4d18-b82c-5f5d9099a804.svg#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5455d207&margin=%5Bobject%20Object%5D&name=jieou.svg&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=true&size=335942&status=done&style=none&taskId=u11608b5c-48bc-4ad3-b36e-9f01adbea9e&title=Chrome%20%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8C%96%E5%9B%BE%EF%BC%8C%E5%B0%86%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%8D%95%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E4%B8%AD",alt:"jieou.svg",title:"Chrome 的服务化图，将不同的服务移动到多个进程和单个浏览器进程中"}})]),t._v(" "),a("h3",{attrs:{id:"特别嘉宾-每个-iframe-的渲染进程-站点隔离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特别嘉宾-每个-iframe-的渲染进程-站点隔离"}},[t._v("#")]),t._v(" 特别嘉宾：每个 iframe 的渲染进程 —— 站点隔离")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://developers.google.com/web/updates/2018/07/site-isolation",target:"_blank",rel:"noopener noreferrer"}},[t._v("站点隔离"),a("OutboundLink")],1),t._v(" 将同一个 tab 内不同 iframe 包裹在不同的进程内运行，以确保 iframe 间资源的独占性，以及安全性。\n"),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy",target:"_blank",rel:"noopener noreferrer"}},[t._v("同源策略"),a("OutboundLink")],1),t._v(" 是 web 的核心安全模型。同源策略确保站点在未得到其它站点许可的情况下不能获取其数据。安全攻击的一个主要目标就是绕过同源策略。进程隔离是分离站点的最高效的手段。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650780548415-aecc9a46-fb62-477d-bd4f-e108e8b4f0fb.webp#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=217&id=ucf0a9482&margin=%5Bobject%20Object%5D&name=iframe.webp&originHeight=433&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=26384&status=done&style=none&taskId=u6b6db05f-0d58-423d-b5ca-5cae598f9d7&title=%E7%AB%99%E7%82%B9%E9%9A%94%E7%A6%BB%E7%A4%BA%E6%84%8F%E5%9B%BE%EF%BC%8C%E5%A4%9A%E4%B8%AA%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E6%8C%87%E5%90%91%E7%AB%99%E7%82%B9%E5%86%85%E7%9A%84%20iframe&width=423",alt:"iframe.webp",title:"站点隔离示意图，多个渲染进程指向站点内的 iframe"}})]),t._v(" "),a("h2",{attrs:{id:"导航时发生了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#导航时发生了什么"}},[t._v("#")]),t._v(" 导航时发生了什么")]),t._v(" "),a("p",[t._v("上个小节我们研究了不同的进程和线程如何处理浏览器的不同部分。\n这个小节研究每个进程和线程如何通信以显示网站。")]),t._v(" "),a("h3",{attrs:{id:"第-1-步-处理输入内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第-1-步-处理输入内容"}},[t._v("#")]),t._v(" 第 1 步：处理输入内容")]),t._v(" "),a("p",[t._v("当用户开始在地址栏键入时，UI 线程要问的第一件事是 “这是一次搜索查询还是一个 URL 地址？”。在 Chrome 中，地址栏同时也是一个搜索输入栏，所以 UI 线程需要解析和决定把你的请求发送到搜索引擎，或是你要请求的网站。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650781900984-fa8d58fc-43a1-4376-a6ca-6e338020dcf3.webp#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=246&id=uf5c939e6&margin=%5Bobject%20Object%5D&name=2-1.webp&originHeight=492&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=25118&status=done&style=none&taskId=u088a4c19-b008-4901-b2e2-d0003a03541&title=UI%20%E7%BA%BF%E7%A8%8B%E8%AF%A2%E9%97%AE%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9%E6%98%AF%E6%90%9C%E7%B4%A2%E6%9F%A5%E8%AF%A2%E8%BF%98%E6%98%AF%20URL%20%E5%9C%B0%E5%9D%80&width=423",alt:"2-1.webp",title:"UI 线程询问输入内容是搜索查询还是 URL 地址"}})]),t._v(" "),a("h3",{attrs:{id:"第-2-步-开始获取网页内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第-2-步-开始获取网页内容"}},[t._v("#")]),t._v(" 第 2 步：开始获取网页内容")]),t._v(" "),a("p",[t._v("当用户按下 Enter 键时，UI 线程启用network 线程获取网页内容。network thread 会寻找合适的协议处理网络请求，一般会通过 "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Domain_Name_System",target:"_blank",rel:"noopener noreferrer"}},[t._v("DNS 协议"),a("OutboundLink")],1),t._v(" 寻址，通过 "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Transport_Layer_Security",target:"_blank",rel:"noopener noreferrer"}},[t._v("TLS 协议"),a("OutboundLink")],1),t._v(" 建立安全链接。如果服务器返回了比如 301 重定向信息，network thread 会通知 UI thread 这个信息，再启动一遍第二步。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650781920604-611ee1dc-0262-4923-bd2e-c824fffddd5e.webp#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=246&id=u256fb6bd&margin=%5Bobject%20Object%5D&name=2-2.webp&originHeight=492&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=27402&status=done&style=none&taskId=u9c14b896-7f89-4dac-8aea-899b802d82b&title=UI%20%E7%BA%BF%E7%A8%8B%E5%91%8A%E8%AF%89%E7%BD%91%E7%BB%9C%E7%BA%BF%E7%A8%8B%E8%A6%81%E5%AF%BC%E8%88%AA%E5%88%B0%20mysite.com&width=423",alt:"2-2.webp",title:"UI 线程告诉网络线程要导航到 mysite.com"}})]),t._v(" "),a("h3",{attrs:{id:"第-3-步-读取响应"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第-3-步-读取响应"}},[t._v("#")]),t._v(" 第 3 步：读取响应")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650781948280-7c1bb6d1-e8f0-4f20-9bb4-d38324f321f0.webp#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=187&id=u6c44d3c0&margin=%5Bobject%20Object%5D&name=2-3.webp&originHeight=374&originWidth=741&originalType=binary&ratio=1&rotation=0&showTitle=true&size=24982&status=done&style=none&taskId=ufc662a21-93c2-4fc4-92b2-f015ee3bf77&title=%E5%8C%85%E5%90%AB%20Content-Type%20%E7%9A%84%E5%93%8D%E5%BA%94%E5%A4%B4%E4%BB%A5%E5%8F%8A%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E6%95%B0%E6%8D%AE%E7%9A%84%20payload&width=371",alt:"2-3.webp",title:"包含 Content-Type 的响应头以及作为实际数据的 payload"}}),t._v("\n一旦开始收到响应主体（payload），network thread 会读取响应内容。在这一步 network thread 会首先读取首部一些字节，即我们常说的响应头，其中包含 "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types",target:"_blank",rel:"noopener noreferrer"}},[t._v("Content-Type"),a("OutboundLink")],1),t._v(" 告知返回内容是什么。如果返回内容是 HTML，则 network thread 会将数据传送给 renderer process，但是如果是一个压缩文件或是其他文件，那么意味着它是一个下载请求，因此需要将数据传递给下载管理器。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650782009027-4d4ef980-b7e1-429f-ad16-77cc387e10e8.webp#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=246&id=u8c965036&margin=%5Bobject%20Object%5D&name=2-4.webp&originHeight=492&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=34444&status=done&style=none&taskId=u2eb54023-6afb-4e35-9ae6-6bbd9c3fa0e&title=%E7%BD%91%E7%BB%9C%E7%BA%BF%E7%A8%8B%E8%AF%A2%E9%97%AE%E4%B8%80%E4%B8%AA%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E6%98%AF%E4%BB%8E%E5%AE%89%E5%85%A8%E7%BD%91%E7%AB%99%E6%9D%A5%E7%9A%84%20HTML&width=423",alt:"2-4.webp",title:"网络线程询问一个响应数据是否是从安全网站来的 HTML"}}),t._v("\n此时也会进行 "),a("a",{attrs:{href:"https://safebrowsing.google.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("SafeBrowsing"),a("OutboundLink")],1),t._v(" 检查。如果域名和响应数据似乎匹配到一个已知的恶意网站，那么网络线程会显示一个警告页面。除此之外，还会发生 "),a("a",{attrs:{href:"https://www.chromium.org/Home/chromium-security/corb-for-developers",target:"_blank",rel:"noopener noreferrer"}},[t._v("CrossOriginReadBlocking（CORB）"),a("OutboundLink")],1),t._v("检查，以确保敏感的跨域数据不被传给渲染进程。")]),t._v(" "),a("h3",{attrs:{id:"第-4-步-查找渲染进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第-4-步-查找渲染进程"}},[t._v("#")]),t._v(" 第 4 步：查找渲染进程")]),t._v(" "),a("p",[t._v("一旦所有检查都完成，network thread 会通知 UI thread 已经准备好跳转了（注意此时并没有加载完所有数据，第三步只是检查了首字节），UI thread 会通知 renderer process 进行渲染。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650782039199-0a99fa12-50e0-42cc-b71c-acc132bb65fd.webp#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=246&id=u5849a26b&margin=%5Bobject%20Object%5D&name=2-5.webp&originHeight=492&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=31894&status=done&style=none&taskId=ub7fd72ed-3835-4405-ad59-ce1c6745af8&title=%E7%BD%91%E7%BB%9C%E7%BA%BF%E7%A8%8B%E5%91%8A%E8%AF%89%20UI%20%E7%BA%BF%E7%A8%8B%E5%8E%BB%E6%9F%A5%E6%89%BE%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B&width=423",alt:"2-5.webp",title:"网络线程告诉 UI 线程去查找渲染进程"}}),t._v("\n由于网络请求会花费几百毫秒才获取回响应，因此可以应用一个优化措施。为了提升性能，UI thread 在通知 network thread 的同时就会实例化一个 renderer process 等着，一旦 network thread 完毕后就可以立即进入渲染阶段，如果检查失败则丢弃提前实例化的 renderer process。")]),t._v(" "),a("h3",{attrs:{id:"第-5-步-提交导航"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第-5-步-提交导航"}},[t._v("#")]),t._v(" 第 5 步：提交导航")]),t._v(" "),a("p",[t._v("现在渲染进程已经就绪，browser process 通过 IPC 向 renderer process 传递数据流。当browser process收到渲染进程已经就绪的消息时，导航完毕并且文档加载解析开始。\n此时导航会被确认，浏览器的各个状态（比如导航状态、前进后退历史）将会被修改，同时为了方便 tab 关闭后快速恢复，会话记录会被存储在硬盘。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650782084845-2d20f139-1028-4c07-ae6f-a57dae972ecc.webp#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=246&id=ue31e62ac&margin=%5Bobject%20Object%5D&name=2-7.webp&originHeight=492&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39672&status=done&style=none&taskId=ud10de500-23e3-4ffd-970b-299554f8283&title=&width=423",alt:"2-7.webp"}})]),t._v(" "),a("h3",{attrs:{id:"额外的步骤-初始加载完毕"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#额外的步骤-初始加载完毕"}},[t._v("#")]),t._v(" 额外的步骤：初始加载完毕")]),t._v(" "),a("p",[t._v("一旦导航被提交，渲染进程开始加载资源和渲染页面。当 renderer process 加载完成后（具体做了什么下一篇会说明），会通知 browser process onLoad 事件，此时浏览器完成最终加载完毕状态，loading 圆圈也会消失，各类 onLoad 的回调触发。\n之所以说“结束”，是因为客户端 JavaScript 可以在这时之后仍然加载额外的资源并且渲染新视图（初始加载结束）。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650782172748-a8a7ea66-ad95-4b73-b04c-2f4c6b3b0968.webp#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=246&id=ufdcf66e2&margin=%5Bobject%20Object%5D&name=2-8.webp&originHeight=492&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33740&status=done&style=none&taskId=uc52850b4-48c3-4e1d-8def-7fc11718f1c&title=&width=423",alt:"2-8.webp"}})]),t._v(" "),a("h2",{attrs:{id:"渲染进程处理网站内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染进程处理网站内容"}},[t._v("#")]),t._v(" 渲染进程处理网站内容")]),t._v(" "),a("p",[t._v("这小节宏观的介绍 renderer process 做了哪些事情。\n浏览器 tab 内 html、css、javascript 内容基本上都由 renderer process 的主线程处理，除了一些 js 代码会放在 web worker 或 service worker 内，所以浏览器主线程核心工作就是解析 web 三剑客并生成可交互的用户界面。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650786005824-cdf1125c-da6f-41bd-8fb0-343999d7e156.webp#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=222&id=ud6078a03&margin=%5Bobject%20Object%5D&name=3-1.webp&originHeight=444&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=28804&status=done&style=none&taskId=uf30f6125-ab69-4598-aaf1-8d9d8816bd4&title=%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E5%86%85%E9%83%A8%E5%8C%85%E5%90%AB%E4%B8%BB%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%88%E6%88%90%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%85%89%E6%A0%85%E7%BA%BF%E7%A8%8B&width=423",alt:"3-1.webp",title:"渲染进程内部包含主线程、工作线程、合成线程和光栅线程"}})]),t._v(" "),a("h3",{attrs:{id:"_1、解析-parsing-构建dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、解析-parsing-构建dom"}},[t._v("#")]),t._v(" 1、解析（Parsing）- 构建DOM")]),t._v(" "),a("h4",{attrs:{id:"dom-的构建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom-的构建"}},[t._v("#")]),t._v(" DOM 的构建")]),t._v(" "),a("p",[t._v("当渲染进程收到导航的提交消息并开始接收 HTML 数据时，主线程（实际上是GUI渲染线程）开始解析文本字符串（HTML）并将其转换为文档对象模型（"),a("strong",[t._v("DOM")]),t._v("）。将 HTML 到 DOM 的解析由 "),a("a",{attrs:{href:"https://html.spec.whatwg.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTML Standard"),a("OutboundLink")],1),t._v(" 规定。")]),t._v(" "),a("h4",{attrs:{id:"tip1-子资源加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tip1-子资源加载"}},[t._v("#")]),t._v(" tip1：子资源加载")]),t._v(" "),a("p",[t._v("网站通常使用图像、CSS 和 JavaScript 等外部资源，这些文件需要从网络或缓存加载。在解析构建 DOM 时，主线程按处理顺序逐个请求它们，但为了加快速度，“预加载扫描器（preload scanner）”会同时运行。如果 HTML 文档中有 "),a("img"),t._v(" 或 "),a("link"),t._v(" 之类的内容，则预加载扫描器会查看由 HTML 解析器生成的标记，并在浏览器进程中向网络线程发送请求。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650786116372-8f441551-4825-4d9e-9591-c47f54c3f3af.webp#clientId=u51f49766-6147-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=222&id=uce151de6&margin=%5Bobject%20Object%5D&name=3-2.webp&originHeight=444&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=34436&status=done&style=none&taskId=u1c5f2adf-a2aa-42bd-84f3-dcd2b2ad085&title=%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90%20HTML%20%E5%B9%B6%E6%9E%84%E5%BB%BA%20DOM%20%E6%A0%91&width=423",alt:"3-2.webp",title:"主线程解析 HTML 并构建 DOM 树"}})]),t._v(" "),a("h4",{attrs:{id:"tip2-javascript-阻塞解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tip2-javascript-阻塞解析"}},[t._v("#")]),t._v(" tip2：JavaScript 阻塞解析")]),t._v(" "),a("p",[t._v("当 HTML 解析器遇到 "),a("code",[t._v("<script>")]),t._v("  标记时，会暂停解析 HTML 文档，开始加载、解析并执行 JavaScript 代码。\n这是为什么呢？\n因为JavaScript 可以使用诸如 document.write() 的方法来改写文档，这会改变整个 DOM 结构（HTML 规范里的 "),a("a",{attrs:{href:"https://html.spec.whatwg.org/multipage/parsing.html#overview-of-the-parsing-model",target:"_blank",rel:"noopener noreferrer"}},[t._v("overview of the parsing model"),a("OutboundLink")],1),t._v(" 中有一张不错的图片）。这就是 HTML 解析器必须等待 JavaScript 运行后再继续解析 HTML 文档原因。")]),t._v(" "),a("h4",{attrs:{id:"tip3-提示浏览器如何加载资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tip3-提示浏览器如何加载资源"}},[t._v("#")]),t._v(" tip3：提示浏览器如何加载资源")]),t._v(" "),a("p",[t._v("开发者可以通过多种方式向浏览器发送提示，以便很好地加载资源。\n如果你的 JavaScript 不使用 document.write()，你可以在 "),a("code",[t._v("<script>")]),t._v("  标签添加 "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async",target:"_blank",rel:"noopener noreferrer"}},[t._v("async"),a("OutboundLink")],1),t._v(" 或 "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-defer",target:"_blank",rel:"noopener noreferrer"}},[t._v("defer"),a("OutboundLink")],1),t._v(" 属性，这样浏览器会异步加载运行 JavaScript 代码，而不阻塞解析。\n如果合适，你也可以使用 "),a("a",{attrs:{href:"https://developers.google.com/web/fundamentals/primers/modules",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript 模块"),a("OutboundLink")],1),t._v("（ES modules）。\n可以使用 "),a("link",{attrs:{rel:"preload"}}),t._v(" 告知浏览器当前导航肯定需要该资源，并且你希望尽快下载。")]),t._v(" "),a("h3",{attrs:{id:"_2、样式计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、样式计算"}},[t._v("#")]),t._v(" 2、样式计算")]),t._v(" "),a("p",[t._v("只有 DOM 是不够的，style 标签申明的样式需要作用在 DOM 上，所以基于 DOM，浏览器要生成 CSSOM，这个 CSSOM 主要是基于 css 选择器（selector）确定作用节点的。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650786716731-7d4130f3-97b4-4d00-b607-ead5d68f9984.webp#clientId=ucb91b397-c390-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=222&id=uf5c68002&margin=%5Bobject%20Object%5D&name=3-2.webp&originHeight=444&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=31166&status=done&style=none&taskId=ub6a0cc68-a701-45ea-8b74-aa396bf360e&title=%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90%20CSS%20%E4%BB%A5%E6%B7%BB%E5%8A%A0%E8%AE%A1%E7%AE%97%E5%90%8E%E6%A0%B7%E5%BC%8F&width=423",alt:"3-2.webp",title:"主线程解析 CSS 以添加计算后样式"}}),t._v("\n即使你不提供任何 CSS，每个 DOM 节点都具有计算样式。像 h1 标签看起来比 h2 标签大，每个元素都有 margin，这是因为浏览器具有默认样式表。")]),t._v(" "),a("h3",{attrs:{id:"_3、布局"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、布局"}},[t._v("#")]),t._v(" 3、布局")]),t._v(" "),a("p",[t._v("现在渲染进程知道了：每个节点的样式和文档的结构，但这不足以渲染页面。想象一下，你正试图通过手机向朋友描述一幅画：“这里有一个大红圈和一个小蓝方块”，这并不能让你的朋友知道这幅画究竟长什么样。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650786796473-806ad1d6-7f06-476e-a84f-8ed1d52d5ff2.webp#clientId=ucb91b397-c390-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=225&id=uf6d15a48&margin=%5Bobject%20Object%5D&name=3-3.webp&originHeight=450&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25120&status=done&style=none&taskId=u349bc53b-0a85-4ae4-9eb0-5400435fecf&title=&width=423",alt:"3-3.webp"}}),t._v('\n布局是计算元素几何形状的过程。主线程遍历 DOM，计算样式并创建布局树，其中包含 x y 坐标和边界框大小等信息。布局树可能与 DOM 树结构类似，但它仅包含页面上可见内容相关的信息。\n如果一个元素应用了 display：none，那么该元素不是布局树的一部分（但 visibility：hidden 的元素在布局树中）。类似地，如果应用了如 p::before{content:"Hi!"} 的伪类，则即使它不在 DOM 中，也包含于布局树中。\n'),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650786909768-02d32d15-724f-4991-a928-7755e962d876.webp#clientId=ucb91b397-c390-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=222&id=u82df3d91&margin=%5Bobject%20Object%5D&name=3-4.webp&originHeight=444&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=30142&status=done&style=none&taskId=u7dea46dc-0635-4f25-a7b9-73ff03939bd&title=%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%81%8D%E5%8E%86%E8%AE%A1%E7%AE%97%E6%A0%B7%E5%BC%8F%E5%90%8E%E7%9A%84%20DOM%20%E6%A0%91%EF%BC%8C%E4%BB%A5%E6%AD%A4%E7%94%9F%E6%88%90%E5%B8%83%E5%B1%80%E6%A0%91&width=423",alt:"3-4.webp",title:"主线程遍历计算样式后的 DOM 树，以此生成布局树"}}),t._v(" "),a("a",{attrs:{href:"https://camo.githubusercontent.com/3cc59da613be023fa3876fcd928ed311276f398050f80c876f38a80093571374/68747470733a2f2f692e6c6f6c692e6e65742f323031382f31302f30372f356262393766643739306331382e676966",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://camo.githubusercontent.com/3cc59da613be023fa3876fcd928ed311276f398050f80c876f38a80093571374/68747470733a2f2f692e6c6f6c692e6e65742f323031382f31302f30372f356262393766643739306331382e676966#crop=0&crop=0&crop=1&crop=1&from=url&height=270&id=oQNG9&margin=%5Bobject%20Object%5D&originHeight=540&originWidth=864&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E7%94%B1%E4%BA%8E%E6%8D%A2%E8%A1%8C%E8%80%8C%E7%A7%BB%E5%8A%A8%E7%9A%84%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80&width=432",alt:"由于换行而移动的盒子布局",title:"由于换行而移动的盒子布局"}}),a("OutboundLink")],1),t._v("\n确定页面布局是一项很有挑战性的任务。即使是从上到下的块流这样最简单的页面布局，也必须考虑字体的大小以及换行位置，这些因素会影响段落的大小和形状，进而影响下一个段落的位置。\nCSS 可以使元素浮动到一侧、隐藏溢出的元素、更改书写方向。可以想象到这一阶段的任务之艰巨。Chrome 浏览器有整个工程师团队负责布局。")]),t._v(" "),a("h3",{attrs:{id:"_4、绘制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、绘制"}},[t._v("#")]),t._v(" 4、绘制")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650787298776-5f8ba7f8-f333-413e-ba5a-bf6cb724f61c.webp#clientId=u19f49fe8-385c-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=159&id=u6121f499&margin=%5Bobject%20Object%5D&name=3-5.webp&originHeight=317&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15032&status=done&style=none&taskId=u4f072f68-4d8f-4e7b-8bdd-e2db2eed0d1&title=&width=423",alt:"3-5.webp"}}),t._v("\n图 7：一个人拿着笔站在画布前，思考着她应该先画圆形还是先画方形\n拥有 DOM、样式和布局仍然不足以渲染页面，因为布局树仅决定了物理结构，但不决定元素的上下空间结构。假设你正在尝试重现一幅画。你知道元素的大小、形状和位置，但你仍需要判断绘制它们的顺序。\n例如，可以为某些元素设置 z-index，此时按 HTML 中编写的元素的顺序绘制会导致错误的渲染。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650787315241-766d5f0d-b0ba-460a-9e50-f9f8fa8fb54c.webp#clientId=u19f49fe8-385c-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=226&id=uf87a8094&margin=%5Bobject%20Object%5D&name=3-6.webp&originHeight=452&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=25888&status=done&style=none&taskId=u2d9a7707-a0dd-429c-a640-fb97dcbe8fb&title=%E5%9B%A0%E4%B8%BA%E6%B2%A1%E6%9C%89%E8%80%83%E8%99%91%20z-index%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E6%8C%89%20HTML%20%E6%A0%87%E8%AE%B0%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%87%BA%E7%8E%B0%EF%BC%8C%E5%AF%BC%E8%87%B4%E9%94%99%E8%AF%AF%E7%9A%84%E6%B8%B2%E6%9F%93%E5%9B%BE%E5%83%8F&width=423",alt:"3-6.webp",title:"因为没有考虑 z-index，页面元素按 HTML 标记的顺序出现，导致错误的渲染图像"}}),t._v("\n在绘制步骤中，主线程遍历布局树，创建绘制记录。绘制记录是绘图过程的记录，就像是“背景优先，然后是文本，然后是矩形”。如果你使用过 JavaScript 绘制了canvas元素，那么这个过程对你来说可能很熟悉。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650787334574-6049cb83-5160-41f0-b5d4-ca0e86adadb0.webp#clientId=u19f49fe8-385c-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=222&id=u48a3b48c&margin=%5Bobject%20Object%5D&name=3-7.webp&originHeight=444&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=26104&status=done&style=none&taskId=ue879a8b4-9e49-46e4-9ea4-a15b6b0c5ba&title=%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%81%8D%E5%8E%86%E5%B8%83%E5%B1%80%E6%A0%91%E5%B9%B6%E7%94%9F%E6%88%90%E7%BB%98%E5%88%B6%E8%AE%B0%E5%BD%95&width=423",alt:"3-7.webp",title:"主线程遍历布局树并生成绘制记录"}})]),t._v(" "),a("h3",{attrs:{id:"_5、合成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、合成"}},[t._v("#")]),t._v(" 5、合成")]),t._v(" "),a("h4",{attrs:{id:"如何绘制一个页面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何绘制一个页面"}},[t._v("#")]),t._v(" 如何绘制一个页面？")]),t._v(" "),a("p",[t._v("现在浏览器知道文档的结构、每个元素的样式、页面的几何形状和绘制顺序，它是如何绘制页面的呢？\n把这些信息转换为屏幕上的像素，我们称为光栅化。\n处理这种情况的一种简单的方法是，先在光栅化视窗内的画面，如果用户滚动页面，则移动光栅框，并填充光栅化缺少的部分。这就是 Chrome 首次发布时处理光栅化的方式，这样做会导致渲染永远滞后于滚动。\n但是，现代浏览器会运行一个更复杂的过程，我们称为合成。\n"),a("a",{attrs:{href:"https://camo.githubusercontent.com/72574f3e5be2dfb005bcae7fa0c6f3c61fd592e367ad8c196f287a43e0bf9a30/68747470733a2f2f692e6c6f6c692e6e65742f323031382f31302f30372f356262393830326536336539642e676966",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://camo.githubusercontent.com/72574f3e5be2dfb005bcae7fa0c6f3c61fd592e367ad8c196f287a43e0bf9a30/68747470733a2f2f692e6c6f6c692e6e65742f323031382f31302f30372f356262393830326536336539642e676966#crop=0&crop=0&crop=1&crop=1&from=url&height=270&id=XoTAQ&margin=%5Bobject%20Object%5D&originHeight=540&originWidth=864&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E7%AE%80%E5%8D%95%E5%85%89%E6%A0%85%E5%A4%84%E7%90%86%E7%A4%BA%E6%84%8F%E5%8A%A8%E7%94%BB&width=432",alt:"简单光栅处理示意动画",title:"简单光栅处理示意动画"}}),a("OutboundLink")],1)]),t._v(" "),a("h4",{attrs:{id:"什么是合成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是合成"}},[t._v("#")]),t._v(" 什么是合成")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://camo.githubusercontent.com/ac674910af089ffdbaad3e05634ab0bc94424a37490b734d06da17f7ba0109a3/68747470733a2f2f692e6c6f6c692e6e65742f323031382f31302f30372f356262393830653932626237632e676966",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://camo.githubusercontent.com/ac674910af089ffdbaad3e05634ab0bc94424a37490b734d06da17f7ba0109a3/68747470733a2f2f692e6c6f6c692e6e65742f323031382f31302f30372f356262393830653932626237632e676966#crop=0&crop=0&crop=1&crop=1&from=url&height=270&id=cGonN&margin=%5Bobject%20Object%5D&originHeight=540&originWidth=864&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%90%88%E6%88%90%E5%A4%84%E7%90%86%E7%A4%BA%E6%84%8F%E5%8A%A8%E7%94%BB&width=432",alt:"合成处理示意动画",title:"合成处理示意动画"}}),a("OutboundLink")],1),t._v("\n合成是一种将页面的各个部分分层，分别光栅化，并在称为合成线程的单独线程中合成页面的技术。\n即将渲染内容分层绘制与渲染，如果发生滚动，由于图层已经光栅化，因此它所要做的只是合成一个新帧。动画也可以以相同的方式（移动图层和合成新帧）实现。\n你可以在 DevTools 使用 "),a("a",{attrs:{href:"https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752?gi=cd6271834cea",target:"_blank",rel:"noopener noreferrer"}},[t._v("Layers 面板"),a("OutboundLink")],1),t._v(" 看看你的网站如何被分层。")]),t._v(" "),a("h4",{attrs:{id:"分层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分层"}},[t._v("#")]),t._v(" 分层")]),t._v(" "),a("p",[t._v("为了分清哪些元素位于哪些图层，主线程遍历布局树创建图层树（此部分在 DevTools 性能面板中称为“Update Layer Tree”）。如果页面的某些部分应该是单独图层（如滑入式侧面菜单）但没拆分出来，你可以使用 CSS 中的 will-change 属性来提示浏览器。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650792150186-3cf96b6c-be51-4c8e-b55c-222c3ec7b684.webp#clientId=u5831dacb-77f3-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=222&id=uf2a08417&margin=%5Bobject%20Object%5D&name=3-9.webp&originHeight=444&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=26354&status=done&style=none&taskId=u6aa2c6a1-2981-4353-9acd-9dbd052dc11&title=%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%81%8D%E5%8E%86%E5%B8%83%E5%B1%80%E6%A0%91%E7%94%9F%E6%88%90%E5%9B%BE%E5%B1%82%E6%A0%91&width=423",alt:"3-9.webp",title:"主线程遍历布局树生成图层树"}}),t._v("\n你可能想要为每个元素都分层，但是合成大量的图层可能会比每帧都光栅化页面的刷新方式更慢，因此测量应用程序的渲染性能至关重要。")]),t._v(" "),a("h4",{attrs:{id:"主线程的光栅化和合成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主线程的光栅化和合成"}},[t._v("#")]),t._v(" 主线程的光栅化和合成")]),t._v(" "),a("p",[t._v("一旦创建了图层树并确定了绘制顺序，主线程就会将该信息提交给合成线程。接着，合成线程会光栅化每个图层。一个图层可能会跟整个页面一样大，因此合成线程将它们分块后发送到光栅线程。光栅线程光栅化每个小块后会将它们存储在显存中。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650792217746-bc7c6d4d-f7af-4d47-bdd4-9840178f874f.webp#clientId=u5831dacb-77f3-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=222&id=ud5d68f81&margin=%5Bobject%20Object%5D&name=3-10.webp&originHeight=444&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=34500&status=done&style=none&taskId=u92b84628-1942-44f5-929a-53b1e321c37&title=%E5%85%89%E6%A0%85%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%88%86%E5%9D%97%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%B9%B6%E5%8F%91%E9%80%81%E5%88%B0%20GPU&width=423",alt:"3-10.webp",title:"光栅线程创建分块的位图并发送到 GPU"}}),t._v("\n合成线程会给不同的光栅线程设置优先级，以便视窗（或附近）内的画面可以先被光栅化。图层还具有多个不同分辨率的块，可以处理放大操作等动作。\n一旦块被光栅化，合成线程会收集这些块的信息（称为"),a("strong",[t._v("绘制四边形")]),t._v("）创建"),a("strong",[t._v("合成帧")]),t._v("。")]),t._v(" "),a("ul",[a("li",[t._v("绘制四边形：包含诸如图块在内存中的位置，以及合成时绘制图块在页面中的位置等信息")]),t._v(" "),a("li",[t._v("合成帧：一个绘制四边形的集合，代表一个页面的一帧。")])]),t._v(" "),a("p",[t._v("接着，合成帧通过 IPC提交给浏览器进程。此时，可以从 UI 线程或其他插件的渲染进程添加另一个合成帧。这些合成器帧被发送到 GPU 然后在屏幕上显示。如果接收到滚动事件，合成线程会创建另一个合成帧发送到 GPU。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650792320984-969b6875-4522-4a84-a84a-1dc4d8ebeb6d.webp#clientId=u5831dacb-77f3-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=222&id=u38857a8d&margin=%5Bobject%20Object%5D&name=3-11.webp&originHeight=444&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=30924&status=done&style=none&taskId=uf02b42ba-6f80-4622-bdd4-13f01cfda08&title=%E5%90%88%E6%88%90%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%90%88%E6%88%90%E5%B8%A7%EF%BC%8C%E5%B0%86%E5%85%B6%E5%8F%91%E9%80%81%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%86%8D%E6%8E%A5%E7%9D%80%E5%8F%91%E9%80%81%E5%88%B0%20GPU&width=423",alt:"3-11.webp",title:"合成线程创建合成帧，将其发送到浏览器进程，再接着发送到 GPU"}}),t._v("\n合成的好处是它可以在不涉及主线程的情况下完成。合成线程不需要等待样式计算或 JavaScript 执行。\n这就是为什么"),a("a",{attrs:{href:"https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/",target:"_blank",rel:"noopener noreferrer"}},[t._v("仅合成动画"),a("OutboundLink")],1),t._v("被认为是流畅性能的最佳选择。\n如果需要再次计算布局或绘制，则必须涉及主线程。")]),t._v(" "),a("h2",{attrs:{id:"用户输入行为与合成器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用户输入行为与合成器"}},[t._v("#")]),t._v(" 用户输入行为与合成器")]),t._v(" "),a("p",[t._v("前面介绍了浏览器的基础进程、线程以及它们之间协同的关系，并重点说到了渲染进程是如何处理页面绘制的，那么最后一节聊到浏览器是如何处理页面中事件的")]),t._v(" "),a("h3",{attrs:{id:"浏览器视角下的输入事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器视角下的输入事件"}},[t._v("#")]),t._v(" 浏览器视角下的输入事件")]),t._v(" "),a("p",[t._v("当你听到“输入事件”（input events）的时候，你可能只会想到：在文本框中输入内容、或者对页面进行了点击操作。从浏览器的角度来看的话，输入其实代表着来自于用户的任何手势动作（gesture）。所以用户滚动页面，触碰屏幕以及移动鼠标等操作都可以看作来自于用户的输入事件。\n当用户做了一些诸如触碰屏幕的手势动作时，浏览器进程（browser process）是第一个可以接收到这个事件的地方。可是浏览器进程只能知道用户的手势动作发生在什么地方而不知道如何处理，这是因为标签内（tab）的内容是由页面的渲染进程（render process）负责的。因此浏览器进程会将事件的类型（如touchstart）以及坐标（coordinates）发送给渲染进程。为了可以正确地处理这个事件，渲染进程会找到事件的目标对象（target）然后运行这个事件绑定的监听函数（listener）\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650792857368-b8a2142f-f229-4732-9abd-ff4461728838.webp#clientId=u5831dacb-77f3-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=212&id=u7a38efcd&margin=%5Bobject%20Object%5D&name=4-1.webp&originHeight=424&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=30432&status=done&style=none&taskId=ue5c5e76c-d383-4731-826d-299ba4ab1a9&title=%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E7%94%B1%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E5%8F%91%E5%BE%80%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B&width=423",alt:"4-1.webp",title:"输入事件由浏览器进程发往渲染进程"}})]),t._v(" "),a("h3",{attrs:{id:"合成器接收输入事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合成器接收输入事件"}},[t._v("#")]),t._v(" 合成器接收输入事件")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://camo.githubusercontent.com/029937949a1625375a46994be683b2a6ccb22ce22271154c3f2fd56a9b585d72/68747470733a2f2f692e6c6f6c692e6e65742f323031382f31302f30382f356262616161336432366239372e676966",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://camo.githubusercontent.com/029937949a1625375a46994be683b2a6ccb22ce22271154c3f2fd56a9b585d72/68747470733a2f2f692e6c6f6c692e6e65742f323031382f31302f30382f356262616161336432366239372e676966#crop=0&crop=0&crop=1&crop=1&from=url&height=270&id=XdN4x&margin=%5Bobject%20Object%5D&originHeight=540&originWidth=864&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=432",alt:""}}),a("OutboundLink")],1),t._v("\n图 2：悬于页面图层的视图窗口\n在上节里，我们探讨了合成器如何通过合成栅格化图层，实现流畅的页面滚动。如果页面上没有添加任何事件监听，合成器线程会创建独立于主线程的新合成帧。但要是页面上添加了事件监听呢？合成器线程又是如何得知事件是否需要处理的？")]),t._v(" "),a("h3",{attrs:{id:"理解非立即可滚动区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#理解非立即可滚动区"}},[t._v("#")]),t._v(" 理解非立即可滚动区")]),t._v(" "),a("p",[t._v("运行 JavaScript 脚本是主线程的工作。所以页面合成后，合成线程会将页面里添加了事件监听的区域标记为“非立即可滚动区”(Non-fast Scrollable Region)。有了这个信息，如果输入事件发生在这一区域，合成线程可以确定应将其发往主线程处理。如输入事件发生在这一区域之外，合成线程则确定无需等待主线程，而继续合成新帧。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650792960326-144c2151-5685-4655-b631-d080101ac4c6.webp#clientId=u5831dacb-77f3-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=236&id=ue5be78a1&margin=%5Bobject%20Object%5D&name=4-2.webp&originHeight=471&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=24594&status=done&style=none&taskId=ufa28f6e5-779c-4b5a-8f81-a5100878442&title=%E9%9D%9E%E7%AB%8B%E5%8D%B3%E5%8F%AF%E6%BB%9A%E5%8A%A8%E5%8C%BA%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E7%A4%BA%E6%84%8F%E5%9B%BE&width=423",alt:"4-2.webp",title:"非立即可滚动区输入描述示意图"}})]),t._v(" "),a("h3",{attrs:{id:"设置事件处理器时须注意"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设置事件处理器时须注意"}},[t._v("#")]),t._v(" 设置事件处理器时须注意")]),t._v(" "),a("p",[t._v("web 开发中常用的事件处理模式是事件代理。因为事件会冒泡，所以你可以在最顶层的元素中添加一个事件处理器，用来代理事件目标产生的任务。下面这样的代码，你可能见过，或许也写过。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addEventListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'touchstart'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("event")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("event"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("target "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" area"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    event"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("preventDefault")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])])]),a("p",[t._v("这样只需添加一个事件处理器，即可监听所有元素，的确十分省事。如果站在浏览器的角度去考量，这等于把整个页面都标记成了“非立即可滚动区”，意味着即便你设计的应用本不必理会页面上一些区域的输入行为，"),a("strong",[t._v("合成线程也必须在每次输入事件产生后与主线程通信并等待返回")]),t._v("。如此则得不偿失，使原本能保障页面滚动流畅的合成器没了用武之地。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650793075209-11396bb0-2d7e-494f-ad65-22c6ff937870.webp#clientId=u5831dacb-77f3-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=236&id=u6b6d6461&margin=%5Bobject%20Object%5D&name=4-4.webp&originHeight=471&originWidth=845&originalType=binary&ratio=1&rotation=0&showTitle=true&size=28706&status=done&style=none&taskId=udac01d72-a090-4fbb-856f-df26960a717&title=%E9%9D%9E%E7%AB%8B%E5%8D%B3%E5%8F%AF%E6%BB%9A%E5%8A%A8%E5%8C%BA%E8%A6%86%E7%9B%96%E6%95%B4%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8B%E7%9A%84%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E7%A4%BA%E6%84%8F%E5%9B%BE&width=423",alt:"4-4.webp",title:"非立即可滚动区覆盖整个页面下的输入描述示意图"}}),t._v("\n你可以给事件监听添加一个 "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners",target:"_blank",rel:"noopener noreferrer"}},[t._v("passive:true"),a("OutboundLink")],1),t._v(" 选项 ，将这种负面效果最小化。这会提示浏览器你想继续在主线程中监听事件，但合成器不必停滞等候，可接着创建新的合成帧。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addEventListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'touchstart'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("event")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("event"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("target "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" area"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    event"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("preventDefault")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("passive")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])])]),a("h3",{attrs:{id:"事件合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件合并"}},[t._v("#")]),t._v(" 事件合并")]),t._v(" "),a("p",[t._v("由于事件触发频率可能比浏览器帧率还要高（1 秒 120 次），如果浏览器坚持对每个事件都进行响应，而一次事件都必须在 js 里响应一次的话，会导致大量事件阻塞，因为当 FPS 为 60 时，一秒也仅能执行 60 次事件响应，所以事件积压是无法避免的。\n为了解决这个问题，浏览器在针对可能导致积压的事件，比如滚动事件时，将多个事件合并到一次 js 中，仅保留最终状态。\n如果不希望丢掉事件中间过程，可以使用 getCoalescedEvents 从合并事件中找回每一步事件的状态：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("window"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addEventListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'pointermove'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("event")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" events "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" event"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getCoalescedEvents")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" event "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" events"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" event"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("pageX"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" y "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" event"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("pageY"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// draw a line using x and y coordinates.")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h2",{attrs:{id:"浏览器内核和js引擎的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器内核和js引擎的关系"}},[t._v("#")]),t._v(" 浏览器内核和JS引擎的关系")]),t._v(" "),a("p",[t._v("浏览器内核（Rendering Engine），是指浏览器最核心的部分，也称“渲染引擎”。\n浏览器内核主要可以分成两部分：排版渲染引擎(layout engineer 或者 Rendering Engine或者渲染引擎)、JS 引擎(如V8)。")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("注意区分渲染引擎和渲染进程")]),t._v(" "),a("strong",[t._v("渲染进程除了渲染引擎，还包括与浏览器进程的通讯线程等等。")]),t._v(" "),a("strong",[t._v("渲染进程，负责使用渲染引擎对源文件进行解析，生成网页交还给浏览器进程进行呈现。同浏览器进程还负责管理渲染进程。")])])]),t._v(" "),a("h3",{attrs:{id:"渲染进程是如何管理进程和使用引擎的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染进程是如何管理进程和使用引擎的"}},[t._v("#")]),t._v(" 渲染进程是如何管理进程和使用引擎的")]),t._v(" "),a("p",[t._v("渲染进程主要包含：")]),t._v(" "),a("h4",{attrs:{id:"gui渲染线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gui渲染线程"}},[t._v("#")]),t._v(" GUI渲染线程")]),t._v(" "),a("ul",[a("li",[t._v("负责渲染浏览器界面，解析HTML,CSS,构建DOM树和RenderObject树，布局和绘制等。")]),t._v(" "),a("li",[t._v("当界面需要重绘或由于某种操作引发回流时，该线程就会执行。")]),t._v(" "),a("li",[t._v("注意，"),a("strong",[t._v("GUI渲染线程与JS引擎线程是互斥的")]),t._v("，当JS引擎执行时GUI线程会被挂起（相当于冻结了）,GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。")])]),t._v(" "),a("h4",{attrs:{id:"js引擎线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js引擎线程"}},[t._v("#")]),t._v(" JS引擎线程")]),t._v(" "),a("ul",[a("li",[t._v("负责处理JavaScript脚本程序。（例如调用V8引擎）。")]),t._v(" "),a("li",[t._v("JS引擎线程负责解析JavaScript脚本，运行代码。")]),t._v(" "),a("li",[t._v("JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（render进程）中无论什么时候都只有一个JS线程在运行JS程序。")]),t._v(" "),a("li",[t._v("同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。")])]),t._v(" "),a("h4",{attrs:{id:"事件触发线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件触发线程"}},[t._v("#")]),t._v(" 事件触发线程")]),t._v(" "),a("ul",[a("li",[t._v("归属于浏览器而不是JS引擎，用来控制事件循环（可以理解成JS引擎自己都忙不过来，需要浏览器另开线程协助）。")]),t._v(" "),a("li",[t._v("当JS引擎执行代码块如setTimeout时（也可来自浏览器内核的其它线程，如鼠标点击，AJAX异步请求等），会将对应任务添加到事件线程中。")]),t._v(" "),a("li",[t._v("当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。")]),t._v(" "),a("li",[t._v("注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）。")])]),t._v(" "),a("h4",{attrs:{id:"定时触发器线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定时触发器线程"}},[t._v("#")]),t._v(" 定时触发器线程")]),t._v(" "),a("ul",[a("li",[t._v("传说中的setTimeout和setInterval所在的线程")]),t._v(" "),a("li",[t._v("浏览器定时计数器并不是由JavaScript引擎计数的，（因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）")]),t._v(" "),a("li",[t._v("因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）")]),t._v(" "),a("li",[t._v("注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。")])]),t._v(" "),a("h4",{attrs:{id:"异步http请求线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步http请求线程"}},[t._v("#")]),t._v(" 异步http请求线程")]),t._v(" "),a("ul",[a("li",[t._v("在XMLHttpRequest在连接后是通过浏览器新建一个线程请求")]),t._v(" "),a("li",[t._v("将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JavaScript引擎执行")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/webp/1352188/1650966211184-bae1807e-d4c1-4f0a-8ffa-1fbf666f4038.webp#clientId=u758a1429-9ef2-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=304&id=ub2d5c61b&margin=%5Bobject%20Object%5D&name=2473796310-5aba11e73b2df_fix732.webp&originHeight=608&originWidth=655&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37918&status=done&style=none&taskId=uf34ffa1a-7d04-4b5a-b127-44f53ffbc84&title=&width=328",alt:"2473796310-5aba11e73b2df_fix732.webp"}})]),t._v(" "),a("h3",{attrs:{id:"再回一下-渲染进程和browser主进程的通信过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#再回一下-渲染进程和browser主进程的通信过程"}},[t._v("#")]),t._v(" 再回一下：渲染进程和Browser主进程的通信过程")]),t._v(" "),a("ul",[a("li",[t._v("Browser主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）,随后将该任务通过RendererHost接口传递给Render渲染进程")]),t._v(" "),a("li",[t._v("Render渲染进程的Renderer接口收到消息，简单解释后，交给渲染线程GUI，然后开始渲染")]),t._v(" "),a("li",[t._v("GUI渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser主进程获取资源和需要GPU进程来帮助渲染")]),t._v(" "),a("li",[t._v("当然可能会有JS线程操作DOM（这可能会造成回流并重绘）")]),t._v(" "),a("li",[t._v("最后Render渲染进程将结果传递给Browser主进程")]),t._v(" "),a("li",[t._v("Browser主进程接收到结果并将结果绘制出来")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/1352188/1650966500458-b78fa364-0d2e-41cb-853e-04327a59d110.png#clientId=u758a1429-9ef2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=198&id=ud3912b9a&margin=%5Bobject%20Object%5D&originHeight=396&originWidth=732&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1ca40c2d-d8fa-4f17-bc1f-f4d7c69b799&title=&width=366",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"js引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js引擎"}},[t._v("#")]),t._v(" JS引擎")]),t._v(" "),a("p",[a("strong",[t._v("为什么需要JS引擎？")]),t._v(" "),a("strong",[t._v("高级的编程语言")]),t._v("都是需要转成"),a("strong",[t._v("最终的机器指令")]),t._v("来执行的，事实上我们编写的JavaScript无论你交给"),a("strong",[t._v("浏览器或者Node")]),t._v("执行,最后都是需要被"),a("strong",[t._v("CPU执行")]),t._v("的。但是CPU只认识自己的指令集,实际上是机器语言,才能被CPU所执行。所以我们需要"),a("strong",[t._v("JavaScript引擎")]),t._v("帮助我们将"),a("strong",[t._v("JavaSCript代码")]),t._v("翻译成"),a("strong",[t._v("CPU指令")]),t._v("来执行。")]),t._v(" "),a("p",[a("strong",[t._v("比较常见的JavaScript引擎有哪些呢?")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("SpiderMonekey")]),t._v(":第一款JavaScript引擎,由BrenDan Eich开发(也就是JavaScript作者)")]),t._v(" "),a("li",[a("strong",[t._v("Chakra")]),t._v(":微软开发,用于IE浏览器")]),t._v(" "),a("li",[a("strong",[t._v("JavaScriptCore")]),t._v(":WebKit中的JavaScript引擎,Apple公司开发")]),t._v(" "),a("li",[a("strong",[t._v("V8")]),t._v(":Google开发的强大JavaScript引擎,也帮助Chrome从众多浏览器中脱颖而出")])]),t._v(" "),a("h3",{attrs:{id:"了解v8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#了解v8"}},[t._v("#")]),t._v(" 了解V8")]),t._v(" "),a("p",[t._v("定义：")]),t._v(" "),a("ul",[a("li",[t._v("V8是用C++编写的Google开源高性能JavaScript和WebAssembly引擎,它用于Chrome和Node.js等.")]),t._v(" "),a("li",[t._v("它实现ECMAScript和WebAssembly,并在Windows7或更高版本,MacOs10.12+和使用x64,IA-32,ARM或MISP处理器的Linux系统上运行")]),t._v(" "),a("li",[t._v("V8可以独立运行,也可以嵌入到任何C++应用程序中")])]),t._v(" "),a("h3",{attrs:{id:"v8引擎的架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎的架构"}},[t._v("#")]),t._v(" V8引擎的架构")]),t._v(" "),a("ul",[a("li",[t._v("V8引擎本身的源码"),a("strong",[t._v("非常复杂")]),t._v(",大概有超过"),a("strong",[t._v("100w行C++代码")]),t._v(",通过了解它的架构,我们可以知道它是如何对JavaScript执行的")]),t._v(" "),a("li",[t._v("Parse模块会将JavaScript代码转换成AST（抽象语法树），这是因为解释器并不直接认识JavaScript代码(如果函数没有被调用，那么是不会被转换成AST的)")]),t._v(" "),a("li",[t._v("Ignition是一个解释器，会将AST转换成ByteCode（字节码）,同时会收集TurboFan优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）,如果函数只调用一次，Ignition会执行解释执行ByteCode;")]),t._v(" "),a("li",[t._v("TurboFan是一个编译器，可以将字节码编译为CPU可以直接执行的机器码；如果一个函数被多次调用，那么就会被标记为"),a("strong",[t._v("热点函数")]),t._v("，那么就会经过"),a("strong",[t._v("TurboFan转换成优化的机器码，提高代码的执行性能")]),t._v("；")])]),t._v(" "),a("h3",{attrs:{id:"v8引擎的解析图-官方"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎的解析图-官方"}},[t._v("#")]),t._v(" V8引擎的解析图(官方)")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/1352188/1650794631755-5c2b57b1-55ad-4666-bb7e-9d6d26c9ae23.png#clientId=u5831dacb-77f3-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=252&id=u041698e7&margin=%5Bobject%20Object%5D&name=5-9.png&originHeight=1008&originWidth=2134&originalType=binary&ratio=1&rotation=0&showTitle=false&size=526089&status=done&style=none&taskId=u2648c826-bd8f-45b2-8ec4-d5dbe7a4a49&title=&width=534",alt:"5-9.png"}})]),t._v(" "),a("h3",{attrs:{id:"v8执行的细节"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8执行的细节"}},[t._v("#")]),t._v(" V8执行的细节")]),t._v(" "),a("p",[t._v("那么我们的JavaScript源码是如何被解析(Parse过程)的呢?")]),t._v(" "),a("ol",[a("li",[t._v("渲染进程将源码交给V8引擎，Stream获取到源码并且进行编码转换")]),t._v(" "),a("li",[t._v("Scanner会进行词法分析(lexical analysis)，词法分析会将代码转换成tokens")]),t._v(" "),a("li",[t._v("接下来tokens会被转换成AST树,经过Parser和PreParser\nParser就是直接将tokens转成AST树架构\nPreParser称之为与解析,为什么需要预解析呢?\n"),a("ul",[a("li",[t._v("这是因为并不是所有的JavaScript代码,在一开始时就会被执行。那么对所有的JavaScript代码进行解析,必然会影响网页的运行效率")]),t._v(" "),a("li",[t._v("所以V8引擎就实现了"),a("strong",[t._v("Lazy Parsing(延迟解析)的方案,它的作用是将不必要的函数进行预解析")]),t._v("，也就是只解析暂时需要的内容，而对"),a("strong",[t._v("函数的全量解析")]),t._v("是在"),a("strong",[t._v("函数被调用时")]),t._v("才会进行")]),t._v(" "),a("li",[t._v("预解析过程中，会验证函数语法是否有效，解析变量声明和函数声明，构建作用域(变量提升)")])])]),t._v(" "),a("li",[t._v("生成AST树后，会被Ignition转成字节码(bytecode)，之后的过程就是代码的编译执行")])]),t._v(" "),a("h3",{attrs:{id:"实例分析一次执行过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例分析一次执行过程"}},[t._v("#")]),t._v(" 实例分析一次执行过程")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/jpeg/1352188/1650873302107-3d2e030c-768f-4f45-adac-ad59c6c4e0f6.jpeg#clientId=u4a83ed14-553c-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u89f8baa8&margin=%5Bobject%20Object%5D&name=v81.c3b8d567.jpeg&originHeight=604&originWidth=1142&originalType=binary&ratio=1&rotation=0&showTitle=false&size=181918&status=done&style=none&taskId=u7f53fdf6-2ee5-4cb4-a045-664e2137fb9&title=",alt:"v81.c3b8d567.jpeg"}})]),t._v(" "),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://developer.chrome.com/blog/inside-browser-part1/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://developer.chrome.com/blog/inside-browser-part1/"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/online-books/dt-fe-weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/219.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%80%E3%80%8B.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("精读现代浏览器"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);